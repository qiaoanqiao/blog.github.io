<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mac下php手动编译debug安装会碰到的问题]]></title>
    <url>%2F%2Fphp-yuan-ma-jie-du%2Fcjz2f3wf3000edf8wnb5isywo.html</url>
    <content type="text"><![CDATA[mac 下 php手动编译 debug 安装会碰到的问题 下载7.1.0版本php源码后进行编译 1./configure --prefix=/usr/local/php7.1.0 --enable-debug --enable-fpm --with-iconv=/usr/local/lib/libiconv --with-config-file-path=/usr/local/php7.1.0/etc mac 需要先切换管理用户 sudo su 再执行 make &amp;&amp; make install 如果碰到一些错误, 请把错误内容 分段 挑选关键词百度或Google 多试试提供的解决方法; 列出两个比较坑的错误解决流程 Undefined symbols for architecture x86_64:“_libiconv”, referenced from: 12345678910111213141516171819202122232425262728293031Undefined symbols for architecture x86_64: &quot;_libiconv&quot;, referenced from: _zif_iconv_substr in iconv.o _zif_iconv_mime_encode in iconv.o _php_iconv_string in iconv.o __php_iconv_strlen in iconv.o __php_iconv_strpos in iconv.o __php_iconv_appendl in iconv.o _php_iconv_stream_filter_append_bucket in iconv.o ... &quot;_libiconv_close&quot;, referenced from: _zif_iconv_substr in iconv.o _zif_iconv_mime_encode in iconv.o _php_iconv_string in iconv.o __php_iconv_strlen in iconv.o __php_iconv_strpos in iconv.o __php_iconv_mime_decode in iconv.o _php_iconv_stream_filter_factory_create in iconv.o ... &quot;_libiconv_open&quot;, referenced from: _zif_iconv_substr in iconv.o _zif_iconv_mime_encode in iconv.o _php_iconv_string in iconv.o __php_iconv_strlen in iconv.o __php_iconv_strpos in iconv.o __php_iconv_mime_decode in iconv.o _php_iconv_stream_filter_factory_create in iconv.o ...ld: symbol(s) not found for architecture x86_64clang: error: linker command failed with exit code 1 (use -v to see invocation)make: *** [libs/libphp7.bundle] Error 1 按照[同类问题](https://stackoverflow.com/questions/40167324/php-compile-fails-with-undefined-symbols-for-architecture-x86-64-libiconv-on-ma)的解决方法 在解决方法中搜索的关键词你如果搜索不到需要改成`EXTRA_LDFLAGS_PROGRAM` 或者拆分一下搜索 然后删除解决方法说的内容 记得前面加上 - ![](https://resource.fenxiangy.com/2019/08/08/15651647274096.jpg!markdown)https://bugs.php.net/bug.php?id=71343https://juejin.im/entry/5b87a081f265da434a1fd98a]]></content>
      <categories>
        <category>PHP源码解读</category>
      </categories>
      <tags>
        <tag>源码安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php中的变量-源码解读]]></title>
    <url>%2F%2Fphp-yuan-ma-jie-du%2Fcjz2f3wfb000zdf8wme1mcgzy.html</url>
    <content type="text"><![CDATA[变量字符串 在定义字符串 赋值给变量, 这个变量gc.u.v.type=6为字符常亮 由此可得字符常亮类型. 不手动创建内存去指向. 赋值变量赋值给另外一个变量 对于简单类型, 如: int null 会直接复制. 对于复杂类型 如 string object 会在写时复制 数组 数组变量 数组有两个类型: packed Array(索引数组) 和 Hash Array(非索引数组) , packed 类型只有两个索引数组 而 packed 则 有八个索引数组. - 当数组中的申键超过8个则会进行`处理`申请增加为`8+8`个桶数组 - `unset`并不会删除数组所占用的内存, 而是类型变为`is_undefined`观看教程:变量基础源码解析]]></content>
      <categories>
        <category>PHP源码解读</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mqtt协议理解]]></title>
    <url>%2F%2Fnote%2Fmqttprotocol.html</url>
    <content type="text"><![CDATA[mqtt协议理解标签（空格分隔）： mqtt 这个协议因为公司需要做物联网方面的东西, 去工厂里面向技术人员讨论告诉我需要的一些技术,让我去琢磨. 上图很好的描述了mqtt在物联网中使用范围 由于物联网的环境是非常特别的，所以MQTT遵循以下设计原则： 精简，不添加可有可无的功能。 发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递。 允许用户动态创建主题，零运维成本。 把传输量降到最低以提高传输效率。 把低带宽、高延迟、不稳定的网络等因素考虑在内。 支持连续的会话控制。 理解客户端计算能力可能很低。 提供服务质量管理。 假设数据不可知，不强求传输数据的类型与格式，保持灵活性。 这些也算是它的优点. 科普一下mqtt 一部分引用别的文章,加上我的理解; 发布/订阅模式 与请求/回答这种同步模式不同，发布/定义模式解耦了发布消息的客户（发布者）与订阅消息的客户（订阅者）之间的关系，这意味着发布者和订阅者之间并不需要直接建立联系。打个比方，你打电话给朋友，一直要等到朋友接电话了才能够开始交流，是一个典型的同步请求/回答的场景；而给一个好友邮件列表发电子邮件就不一样，你发好电子邮件该干嘛干嘛，好友们到有空了去查看邮件就是了，是一个典型的异步发布/订阅的场景。熟悉编程的同学一定非常熟悉这种设计模式了，因为它带来了这些好处： 从上面可以知道: 发布者与订阅者不必了解彼此，只要认识同一个消息代理(服务端)即可。发布者和订阅者不需要交互，发布者无需等待订阅者确认而导致锁定。发布者和订阅者不需要同时在线，可以自由选择时间来消费消息(这个要注意消息类型)。 ps:其实这种可以用生活中使用的微信形象解释这种 消息模式 :甲给乙发送一个消息;(其中就相当于甲发布了一个消息,而发布消息的目标是乙订阅的主题,只是这个主题是乙收消息的主题,甲传过来的消息可以分解为:发送人,发送的消息这样的参数) 乙不需要在线,但是在线就可以接收; 乙给甲发消息;甲订阅了个接收消息的主题,而乙就是发到这个主题中![消息发送订阅][3] 主题 MQTT是通过主题对消息进行分类的，本质上就是一个UTF-8的字符串，不过可以通过反斜杠表示多个层级关系。主题并不需要创建，直接使用就是了。主题还可以通过通配符进行过滤。其中，+可以过滤一个层级，而*只能出现在主题最后表示过滤任意级别的层级。举个例子： building-b/floor-5：代表B楼5层的设备。 +/floor-5：代表任何一个楼的5层的设备。 building-b/*：代表B楼所有的设备。注意，MQTT允许使用通配符订阅主题，但是并不允许使用通配符广播(发送消息)。 通配符: 主题层级分隔符: / / 被用来分割主题树的每一层，并给主题空间提供分等级的结构。当两个通配符在一个主题中出现的时候，主题层次分隔符的使用是很重要的。 ps:类似于新闻分类中的结构 / 全球新闻/中国新闻/码农新闻 单层通配符+ + 只匹配主题的一层。比如说，finance/stock/+匹配finance/stock/ibm和finance/stock/xyz，但是不匹配finance/stock/ibm/closingprice。另外，因为单层通配符只匹配1层，finance/+不匹配finance。 单层通配符可以被用于主题树的任意层级，连带多层通配符。它必须被用在主题层级分隔符/的右边，除非它是指定自己。因此，+和finance/+都是有效的，但是finance+无效。单层通配符可以用在主题树的末端，也可以用在中间。比如说，finance/+和finance/+/ibm都是有效的。 ps:匹配一层就是匹配 全球新闻/ 而订阅 码农新闻 的人并不能收到发送给 全球新闻/ 这个有通配符的主题的信息 多层通配符: # # 是一个匹配主题中任意层次数的通配符。比如说，如果你订阅了finance/stock/ibm/#，你就可以接收到以下这些主题的消息。 1234&gt;finance/stock/ibm&gt;finance/stock/ibm/closingprice&gt;finance/stock/ibm/currentprice&gt; 多层通配符有可以表示大于等于0的层次。因此，finance/#也可以匹配到单独的finance，在这种情况下#代表0层。在这种语境下主题层次分隔符/就没有意义了。因为没有可以分的层次。 多层通配符只可以确定当前层或者下一层。因此，#和finance/#都是有效的，但是finance#不是有效的。多层通配符一定要是主题树的最后一个字符。比如说，finance/#是有效的，但是finance/#/closingprice是无效的。 ps:多层匹配就是匹配 全球新闻 下的所有子主题 订阅 码农新闻 的人能收到发送给 全球新闻/# 这个有通配符的主题的信息 主题语法和用法 当你建立一个应用，设计主题树的时候应该考虑以下的主题名字的语法和语义： 主题至少有一个字符长。 主题名字是大小写敏感的。比如说，ACCOUNTS和Accounts是两个不同的主题。 主题名字可以包含空格。比如，Accounts payable是一个有效的主题。 以/开头会产生一个不同的主题。比如说，/finnace与finance不同。/finance匹配”+/+”和/+,但不匹配+ 不要在任何主题中包含null（Unicode \x0000）字符。 以下的原则应用于主题树的建造和内容 在主题树中，长度被限制于64k内但是在这以内没有限制层级的数目 。 可以有任意数目的根节点；也就是说，可以有任意数目的主题树。 服务质量 为了满足不同的场景，MQTT支持三种不同级别的服务质量（Quality of Service，QoS）为不同场景提供消息可靠性： 级别0：尽力而为。消息发送者会想尽办法发送消息，但是遇到意外并不会重试。 级别1：至少一次。消息接收者如果没有知会或者知会本身丢失，消息发送者会再次发送以保证消息接收者至少会收到一次，当然可能造成重复消息。 级别2：恰好一次。保证这种语义肯待会减少并发或者增加延时，不过丢失或者重复消息是不可接受的时候，级别2是最合适的。 服务质量是个老话题了。级别2所提供的不重不丢很多情况下是最理想的，不过往返多次的确认一定对并发和延迟带来影响(不适合api)。级别1提供的至少一次语义在日志处理这种场景下是完全OK的，所以像Kafka这类的系统利用这一特点减少确认从而大大提高了并发。级别0适合鸡肋数据场景，食之无味弃之可惜，就这么着吧。 ps:所以还是用级别1写api吧.0有点不稳妥,万一哪天发送个表白消息到妹子那里,妹子没收到造成不回复你.你还以为妹子不同意,或者默认… 消息类型MQTT拥有14种不同的消息类型(报文的类型)： 1234567891011121314CONNECT：客户端连接到MQTT代理CONNACK：连接确认PUBLISH：新发布消息PUBACK：新发布消息确认，是QoS 1给PUBLISH消息的回复PUBREC：QoS 2消息流的第一部分，表示消息发布已记录PUBREL：QoS 2消息流的第二部分，表示消息发布已释放PUBCOMP：QoS 2消息流的第三部分，表示消息发布完成SUBSCRIBE：客户端订阅某个主题SUBACK：对于SUBSCRIBE消息的确认UNSUBSCRIBE：客户端终止订阅的消息UNSUBACK：对于UNSUBSCRIBE消息的确认PINGREQ：心跳PINGRESP：确认心跳DISCONNECT：客户端终止连接前优雅地通知MQTT代理 搭配一个我在测试时所分析的服务器的消息日志更清晰看到使用: 1234567891011121314151617181920212223242526272829303132333435New connection from 192.168.1.166 on port 1883.1520560007: New client connected from 192.168.1.166 as 036914380929367040071489983908 (c1, k60).-新的连接 客户端连接指定的ClientID为036914380929367040071489983908 清除session k60: 表示keep-alive=60s1520560007: Sending CONNACK to 036914380929367040071489983908 (0, 0)-发送连接ACK包给客户端 1520560007: Received SUBSCRIBE from 036914380929367040071489983908-服务器收到一个来自ClientID为036914380929367040071489983908的订阅请求 1520560007: SN69143809293670ctr (QoS 0)-服务器识别036914380929367040071489983908订阅的主题为 SN69143809293670ctr，指定的QOS=0遗嘱保留被设置为 0，服务端必须将遗嘱消息当作非保留消息发布1520560007: 036914380929367040071489983908 0 SN69143809293670ctr-给ClientID=036914380929367040071489983908客户端发送订阅SN69143809293670ctr ACK回包1520560007: Sending SUBACK to 036914380929367040071489983908-服务器发送内容给客户端日志1520560017: Received PUBLISH from 036914380929367040071489983908 (d0, q0, r0, m0, &apos;SN69143809293670state&apos;, ... (99 bytes))-服务器正在发送一个消息给ClientID=036914380929367040071489983908的客户端，消息体大小为99 bytes，消息主题为‘SN69143809293670state’(d0, q2, r0, m0)的解释, 以下参数具体含义，参考MQTT协议 d: 表示mqtt报头的DUP字段 q: 表示的QOS字段 r: 表示的是RETAIN m: 表示的是消息ID,即mid ps:这个东西可以参考一下官方文档; 传送门 MQTT代理(算是服务端了)市面上有相当多的高质量MQTT代理，其中mosquitto是一个开源的轻量级的C实现，完全兼容了MQTT 3.1和MQTT 3.1.1。下面我们就以mosquitto为例演示一下MQTT的使用。环境是百度开放云的云服务器以及Ubuntu 14.04.1 LTS，简单起见MQTT代理和客户端都安装在同一台云服务器上了。centos安装方法 首先SSH到云服务器，安装mosquitto以及搭配的客户端：apt-get install mosquittoapt-get install mosquitto-clients 现在在云端模拟云服务，订阅某办公楼5层的温度作为主题： mosquitto_sub -d -t ‘floor-5/temperature’Received CONNACKReceived SUBACKSubscribed (mid: 1): 0 然后另外打开一个SSH连接，模拟温度计发送温度消息：mosquitto_pub -d -t ‘floor-5/temperature’ -m ‘15’Received CONNACKSending PUBLISH (d0, q0, r0, m1, ‘floor-5/temperature’, … (2 bytes)) 此时回到第一个SSH客户端可以看到信息已经接收到了，之后便是心跳消息： Received PUBLISH (d0, q0, r0, m0, ‘floor-5/temperature’, … (2 bytes))15Sending PINGREQReceived PINGRESP 需要注意的是mosquitto客户端默认使用QoS 0，下面我们使用QoS 2订阅这个主题： mosquitto_sub -d -q 2 -t ‘floor-5/temperature’Received CONNACKReceived SUBACKSubscribed (mid: 1): 2 切换到另外SSH连接然后在这个主题里面发送温度消息： mosquitto_pub -d -q 2 -t ‘floor-5/temperature’ -m ‘15’Received CONNACKSending PUBLISH (d0, q2, r0, m1, ‘floor-5/temperature’, … (2 bytes))Received PUBREC (Mid: 1)Sending PUBREL (Mid: 1)Received PUBCOMP (Mid: 1) 此时回到第一个SSH客户端可以看到信息已经接收到了，以及相应的多次握手消息： Received PUBLISH (d0, q2, r0, m1, ‘floor-5/temperature’, … (2 bytes))Sending PUBREC (Mid: 1)Received PUBREL (Mid: 1)15Sending PUBCOMP (Mid: 1) 至此我们初步了解了MQTT的基本知识！接下来会发布mqtt在php和node.js中的使用文章,敬请期待;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>mqtt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[supervisor 进程管理工具 (监听、启动、停止、重启一个或多个进程或自动重启)]]></title>
    <url>%2F%2Fnote%2Fsupervisor-process-management-tool-listen-start-stop-restart-one-or-more-processes-autorestart.html</url>
    <content type="text"><![CDATA[教程方向: 快速上手, 解决使用中遇到的一些问题使用环境: Centos7.2 安装:yum install supervisor 配置安装好后在/etc/会生成一个supervisord.conf文件及一个supervisord.d文件目录 Supervisord.conf是一些默认配置，可自行参考一些配置文件教程修改 我们主要修改 /etc/supervisord.conf 文件的最后一行: 12[include]files = relative/directory/*.ini ;可以指定一个或多个以.ini结束的配置文件 这里配置的是引入型配置, 会自动引入配置的目录下的配置文件 注意：[include]默认配置是制定.ini，因个人习惯命名为.conf文件，因此修改配置如下： 我们将配置目录改为自己想要的目录下后, 在目录下建立配置文件, 以frpc 为例. /root/supervisord_conf/frpc.ini 1234567[program:frpc]command=/home/vagrant/frp/frp/frpc -c /home/vagrant/frp/frp/frpc.iniuser=rootautostart=trueautorestart=truestderr_logfile=/home/vagrant/frp/frp/err.logstdout_logfile=/home/vagrant/frp/frp/out.log 其他配置文件对应参考注释: 12345678910111213[program:usercenter]directory = /home/Leon/projects/usercenter ; 程序的启动目录command = gunicorn -w 8 -b 0.0.0.0:17510 wsgi:app ; 启动命令autostart = true ; 在 supervisord 启动的时候也自动启动Startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了autorestart = true ; 程序异常退出后自动重启Startretries = 3 ; 启动失败自动重试次数，默认是 3user = Leon ; 用哪个用户启动redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 falsestdout_logfile_maxbytes = 20MB ; stdout 日志文件大小，默认 50MBstdout_logfile_backups = 20 ; stdout 日志文件备份数; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile = /data/logs/usercenter_stdout.log 注意: 配置中所指向的文件需要提前存在,否则会遇到错误. 启动并运行 执行: supervisord -c /etc/supervisord.conf 启动supervisord服务端 查看 supervisord 是否在运行： ps aux | grep supervisord 可能会碰到的错误: python 不推荐使用的包 12 /usr/lib/python2.7/site-packages/supervisor/options.py:383: PkgResourcesDeprecationWarning: Parameters to load are deprecated. Call .resolve and .require separately.return pkg_resources.EntryPoint.parse(&quot;x=&quot;+spec).load(False) 这个打印并不影响使用,如果想解决这个错误可以参考 github issues 重复启动错误 supervisorctl unix:///var/run/supervisor.sock refused connection 说明 已经启动 需要执行 supervisorctl shutdown终止进程再启动 开启了supervisord后需要使用 supervisorctl 管理 开启所有进程守护 supervisorctl start all 再执行 supervisorctl status 会看到: 12 [root@localhost supervisord_conf]# supervisorctl statusfrpc RUNNING pid 7989, uptime 0:10:15 其他命令 1234567891011121314$ supervisorctl status$ supervisorctl stop frpc$ supervisorctl start frpc$ supervisorctl restart frpc$ supervisorctl reread$ supervisorctl update解释:&gt; status # 查看程序状态&gt; stop usercenter # 关闭 usercenter 程序&gt; start usercenter # 启动 usercenter 程序&gt; restart usercenter # 重启 usercenter 程序&gt; reread ＃ 读取有更新（增加）的配置文件，不会启动新添加的程序&gt; update ＃ 重启配置文件修改过的程序 参考资料官方文档摘抄摘抄感觉不错]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发文档案例]]></title>
    <url>%2F%2Ftechnology-php%2Fdevelopment-document-case.html</url>
    <content type="text"><![CDATA[能愿动词为了避免歧义，文档大量使用了「能愿动词」，对应的解释如下： 必须（Must） - 只能这样子做，请无条件遵循，没有别的选项；绝不（Must Not）- 严令禁止，在任何情况下都不能这样做；应该（Should） - 强烈建议这样做，但是不强求；不应该（Should Not） - 强烈建议不这样做，但是不强求；可以（May） - 选择性高一点，在这个文档内，此词语使用较少； 开发流程规范: 应该使用自定义表单验证类,避免方法体过多类似功能代码段. 编写方法时应该声明返回类型 12 `public function create(Create $request): JsonResponse &#123;` 每个方法 必须 写上规范注释. 用户信息访问 应该 使用Auth门面, Auth已经过框架自动载入,具体使用方法参照现有代码. 应该 使用一个return 进行数据返回. 固定值访问应该 使用config()访问语义化词汇获得 如config(&#39;common_config.premium.min&#39;). 编写业务代码时遵循依赖框架原则,框架可以提供便利的尽量使用框架提供的功能. controller层仅作为基础判断使用,繁杂业务逻辑 应该 在Service层进行处理. 对存入数据的操作应该使用模型处理. 对一对多,多对多,多对一等模型数据访问时,尽量 使用框架自带的模型关联功能 关键性操作流程 应该 注入 事件 方便业务功能. 数据库表增删改 必须 使用数据库迁移 创建表后应该编写相应的数据工厂文件. 开发时应该先编写对应的单元测试. 应该 对表单数据进行类型校验,可以在表单验证中加上. 其他规范应该参照: Laravel 项目开发规范 接口 请求 接口 必须 统一使用api路由, POST请求统一放置在POST请求路由组; POST 请求路由 必须 使用 post 路由前缀, 中间件应该 使用与之相对的中间件 表单校验:接口路由指向的方法中请求信息参数 必须 使用自定表单验证类依赖注入校验表单填写是否正确, 自定义表单验证类中 应在类体中 使用 use UnifiedFormat; 处理表单验证类自动处理的返回内容适用到项目. Api的路由 必须 使用 name 方法标注, 标注中以 . 分隔, 标注代表着此接口的权限管理项的标注, 用于后期添加权限; 注意标注的末尾动作如下表格, 其他行为应该使用功能翻译英文标记 Api.前缀.功能(英文并可以多个 . 分隔).操作词 动词 描述 是否幂等 show 获取资源，单个 是 index 获取资源，多个 是 create 创建资源 否 PATCH 更新资源，客户端提供部分的资源数据 否 DELETE 删除资源 是 应该 使用 api 资源 返回数据资源. 响应 响应使用Res门面 use Res; 可使用具体方法在 app/Http/Controllers/Auth/Api/ResponseMsg.php 具体使用规则参考部分接口控制器代码 注意事项 使用复杂多表查询时注意软删除和一些模型无感知提供的功能的处理. 编写代码之前 应该 读懂 框架核心架构 api系统剥离只需要修改auth config/auth.php defaults=&gt;guard 三维数组中 web 变为 otcapi, apiverify中间件中handle方法 注释内容开启, 未注释内容注释]]></content>
      <categories>
        <category>PHP技术栈</category>
      </categories>
      <tags>
        <tag>开发文档案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[larval-admin拓展-使用备注]]></title>
    <url>%2F%2Ftechnology-php%2Flarvaladmin-extension-use-notes.html</url>
    <content type="text"><![CDATA[主要布局类Encore\Admin\Form类用于生成基于数据模型的表单，先来个例子，中数据库有movies表 Encore\Admin\Grid类用于生成基于数据模型的表格，先来个例子，中数据库有movies表 Model-grid默认有两个行操作编辑和删除，可以通过下面的方式关闭它们： Model-grid内置了很多对于列的操作方法，可以通过这些方法很灵活的操作列数据。 在model-grid的头部默认有批量删除和刷新两个操作工具，如果有更多的操作需求，model-grid提供了自定义工具的功能,下面的示例添加一个性别分类选择的按钮组工具。 Model-grid提供了一系列的方法实现表格数据的查询过滤： Model-form使用laravel的验证规则来验证表单提交的数据： Model-form目前提供了下面几个方法来接收 保存 回调函数： Encore\Admin\Show用来显示数据详情，先来个例子，中数据库有posts表： 通过可以model-tree来实现一个树状组件，可以用拖拽的方式实现数据的层级，排序等操作，下面是基本的用法。 在页面调用下面的方法，它将会调用toastr组件，在页面的右上角添加一条浮动的提示 Encore\Admin\Widgets\Box用来生成box组件： 使用方式 创建模型对应的增删改查控制器和模型 php artisan admin:make UserController --model=App\\User 在 web.php 中添加资源访问路由 $router-&gt;resource(&#39;users&#39;, UserController::class); 在后台系统 链接:/admin/auth/menu 中添加左侧菜单栏连接 剩下的工作就是构建数据表格和表单了，打开 app/Admin/Contollers/UserController.php,找到show()、grid()和form()方法，然添加构建代码更多详细使用请查看model-grid和model-form。 上手感触 在使用这个后台系统中, 如果按照设计图来弄不是太理想和方便, 例如表单太长只能用自带的 选项卡切换分组方式 : model-form-tab 如果表单元素太多,会导致form页面太长, 这种情况下可以使用tab来分隔form: 对于列和行 属于栅栏式布局 由于有些需求效果可能还需要做接口]]></content>
      <categories>
        <category>PHP技术栈</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云日志服务监控访问日志]]></title>
    <url>%2F%2Fnote%2Falibaba-cloud-log-service-monitors-access-logs.html</url>
    <content type="text"><![CDATA[添加日志服务 网址 点击创建Project 名称填好,所属区域选择需要监控的服务器的所在区域 接下来会出现弹出窗: 点击创建,或不小心关掉 点击名称进入下列2图界面 创建Logstore 这些根据提示填写好就行了. 数据接入 点击确认会出现此框点击数据接入向导,如果没有在2图数据接入想到下面有个按钮点几下 选择你需要的 - 配置规则. 这里要注意的只有日志路径, 注意仔细看备注.我的是: 第一个选项:/wwwlogs 第二个选框: *.log 如果担心自己获取到了,但是不显示也不知道出现什么问题,那就展开高级选项按照如图配置 - 填写好后点击下一步这一步比较重要,是能不能获取到日志的关键 关于机器组:需要用到阿里云的教程搭建个日志服务 - 点击创建机器组 - 点击帮助 进入https://help.aliyun.com/document_detail/28982.html?spm=5176.2020520112.116.d11.8c2434c0IPMoLR 安装Logtail; - 点击安装方式中的一个 我选的是阿里云内网,因为是阿里的机器 - 执行命令安装 安装成功 - 填写信息: 根据日志服务里选择的区域,再填入ip - 随后点击应用到机器组 - 进入机器组列表 机器的操作中的查看状态 心跳ok就没问题 监控分析 随后点击日志库: - 点击查询分析下的查询: 点确定 - 右上角有开启索引 - 出现这个,我的是nginx所以点nginx模板 然后等待一分钟左右,期间可在这里点监控 - 如果没有数据检查: 点击蓝色名字配置 左边有些选项均有文档,仔细看]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel服务提供者和门面及契约整理]]></title>
    <url>%2F%2Fnote%2Flaravel-service-provider-and-facade-contract.html</url>
    <content type="text"><![CDATA[标签（空格分隔）： laravel 服务提供者通俗意思是:你家需要水,服务提供者送水的;服务提供者生成后的代码 Contracts, ServiceContainer, ServiceProvider, Facades关系概念Contracts 合同，契约，也就是接口，定义一些规则，每个实现此接口的都要实现里面的方法 ServiceContainer 实现Contracts,具体的逻辑实现 ServiceProvider ServiceContainer的服务提供者，返回ServiceContainer的实例化，供其他地方使用，可以把它加入到app/config的provider中，会被自动注册到容器中 Facades 简化ServiceProvider的调用方式，而且可以静态调用ServiceContainer中的方法 php artisan make:provider FooServiceProvider 123456789101112131415161718192021222324252627namespace App\Providers;use Illuminate\Support\ServiceProvider;use App\lib\Tools\FooBar\FooBar;class FooServiceProvider extends ServiceProvider&#123; /** * Bootstrap the application services. * * @return void */ public function boot() &#123; // &#125; /** * Register the application services. * * @return void */ public function register() &#123; &#125;&#125; 其中boot在框架加载初期就载入就提供,如果你提供的水还需要矿物质什么的(框架内一些依赖) 就不要在这里进行提供; 在一个继承服务提供者的文件内boot方法register方法都可以使用 123$this-&gt;app-&gt;bind(&apos;test&apos;,function()&#123; return new Test();&#125;); 方式提供依赖这种写法理解思路可以参照:链接 在平时方法中使用: 1234567public function two($id=null)&#123; //从系统容器中获取实例化对象// $myfoo = app(&apos;test&apos;);// app()-&gt;make(&apos;test&apos;); $myfoo = \App::make(&apos;test&apos;); echo $myfoo-&gt;get();&#125; 或在 方法参数中加上依赖地址或名称; 123use App\lib\Tools\FooBar\Test;public function index(Test $test) 根据文章:地址整理思路 门面门面定义 123456789101112namespace App\CustomFacades;use Illuminate\Support\Facades\Facade;class Foo extends Facade&#123; protected static function getFacadeAccessor() &#123; return &apos;test&apos;; &#125;&#125; 继承Illuminate\Support\Facades\FacadegetFacadeAccessor()中return ‘test’代表服务提供者代码中 123$this-&gt;app-&gt;bind(&apos;test&apos;,function()&#123; return new Test();&#125;); 的test 在app.php aliases 数组中添加‘Foo’ =&gt; App\CustomFacades\Foo::class, 契约参考网址:https://www.jb51.net/article/135189.htmhttps://www.cnblogs.com/redirect/p/6087810.htmlhttp://laravelacademy.org/post/769.htmlhttps://www.cnblogs.com/cyforever/p/6139109.html]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对接币种钱包 资料整理]]></title>
    <url>%2F%2Fnote%2Fdocking-currency-wallet.html</url>
    <content type="text"><![CDATA[https://blog.csdn.net/rejames/article/details/82884508 https://github.com/aceat64/EasyBitcoin-PHP https://blog.csdn.net/wudwolf/article/details/79190084 https://bitcoin.org/en/developer-reference#raw-transaction-format https://blog.csdn.net/rejames/article/details/82885483 合约币https://hk.saowen.com/a/96d9c72062eed314bab4a1353d6de0f0cd492909fd8704c1f0eb2e674c8d670d https://hk.saowen.com/a/a3c33a6d50f274e9e0600a996442942194a681a6eeaf8962c1a04870ac96c320 ￼]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>对接币种钱包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grpc生成php代码(composer)]]></title>
    <url>%2F%2Fnote%2Fgrpc-generates-php-code-composer.html</url>
    <content type="text"><![CDATA[解决朋友不会编译问题写的备注 先去下载源码包https://github.com/protocolbuffers/protobuf/releases 解压后进入目录里面运行 12./configure --prefix=/usr/local/protobufmake &amp;&amp; make install 获取.proto的文件放到指定目录 在指定文件目录执行: 1/usr/local/protoc/bin/protoc --php_out=. zpt.proto 文档:https://developers.google.com/protocol-buffers/docs/reference/php-generated参考:https://my.oschina.net/laixhe/blog/1476644https://www.cnblogs.com/chunguang/p/5618588.htmlhttps://github.com/protocolbuffers/protobuf/tree/master/phphttps://developers.google.com/protocol-buffers/docs/downloads]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php 数据转json 中文转码问题]]></title>
    <url>%2F%2Fnote%2Fphp-data-to-json-chinese-transcoding-problem.html</url>
    <content type="text"><![CDATA[我们知道, 用PHP的json_encode来处理中文的时候, 中文都会被编码, 变成不可读的, 类似”\u***”的格式, 还会在一定程度上增加传输的数据量. &lt;?php echo json_encode(&quot;中文&quot;); //&quot;\u4e2d\u6587&quot;这就让我们这些在天朝做开发的同学, 很是头疼, 有的时候还不得不自己写json_encode. 而在PHP5.4, 这个问题终于得以解决, Json新增了一个选项: JSON_UNESCAPED_UNICODE, 故名思议, 就是说, Json不要编码Unicode. 看下面的例子: &lt;?php echo json_encode(&quot;中文&quot;, JSON_UNESCAPED_UNICODE); //&quot;中文&quot;怎么样, 是不是让大家很开心的改动? 呵呵, 当然, Json在5.4还加入了: JSON_BIGINT_AS_STRING, JSON_PRETTY_PRINT, JSON_UNESCAPED_SLASHES等选项, 如果有兴趣, 大家可以参看: json_encode 不过, 还是要提醒下: PHP 5.4还处于开发阶段, 在最终release之前, 任何新特性都可能被调整或者更改. 如果大家有任何建议, 也欢迎反馈, 帮助我们使得PHP变得更好. 本文转载文章 http://www.laruence.com/2011/10/10/2239.html]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>解决问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php 修改数组配置文件]]></title>
    <url>%2F%2Fnote%2Fphp-modify-array-configuration-file.html</url>
    <content type="text"><![CDATA[Thinkphp 12345678910111213141516171819/** * 刷新配置文件 */ protected function refreshFile() &#123; $config = []; foreach ($this-&gt;model-&gt;all() as $k =&gt; $v) &#123; $value = $v-&gt;toArray(); if (in_array($value['type'], ['selects', 'checkbox', 'images', 'files'])) &#123; $value['value'] = explode(',', $value['value']); &#125; if ($value['type'] == 'array') &#123; $value['value'] = (array)json_decode($value['value'], TRUE); &#125; $config[$value['name']] = $value['value']; &#125; file_put_contents(APP_PATH . 'extra' . DS . 'site.php', '&lt;?php' . "\n\nreturn " . var_export($config, true) . ";"); &#125; 其中 var_export函数是重点 函数官方文档传送门]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>解决问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单元测试文档学习笔记]]></title>
    <url>%2F%2Fnote%2Funit-test-document-study-notes.html</url>
    <content type="text"><![CDATA[注意事项: 编写单元测试,方法块注释不随意填写, 防止出现使用单元测试提供的注释语法无法使用 注释依赖(测试中的流程控制) 当某个测试所依赖的测试 失败时，PHPUnit 会跳过这个测试。 例如:测试a 需要 测试b获取的值 来进行测试a的测试;可以用注释依赖进行值传递 如果测试同时从 @dataProvider 方法和一个或多个 @depends 测试接收数据，那么来自于数据供给器的参数将先于来自所依赖的测试的。来自于所依赖的测试的参数对于每个数据集都是一样的。 如果一个测试依赖于另外一个使用了数据供给器的测试，仅当被依赖的测试至少能在一组数据上成功时，依赖于它的测试才会运行。使用了数据供给器的测试，其运行结果是无法注入到依赖于此测试的其他测试中的。 详细使用参考: 手册 数据供给器(自动迭代) 测试a 需要多种数据进行测试, 用数据供给器后,会自动迭代测试数据供给器提供的数据进行测试. 测试方法可以接受任意参数。这些参数由数据供给器方法（在 writing-tests-for-phpunit.data-providers.examples.DataTest.php中，是 ``additionProvider() 方法）提供。用 @dataProvider 标注来指定使用哪个数据供给器方法。 数据供给器方法必须声明为 public，其返回值要么是一个数组，其每个元素也是数组；要么是一个实现了 Iterator 接口的对象，在对它进行迭代时每步产生一个数组。每个数组都是测试数据集的一部分，将以它的内容作为参数来调用测试方法。 Example 2.5 使用返回数组的数组的数据供给器 123456789101112131415161718192021222324&lt;?phpuse PHPUnit\Framework\TestCase; class DataTest extends TestCase&#123; /** * @dataProvider additionProvider */ public function testAdd($a, $b, $expected) &#123; $this-&gt;assertEquals($expected, $a + $b); &#125; public function additionProvider() &#123; return [ [0, 0, 0], [0, 1, 1], [1, 0, 1], [1, 1, 3] ]; &#125;&#125;?&gt; 详细使用参考: 手册 测试出现异常:标注来测试被测代码中是否抛出了异常。 php原生异常 使用PHPUnit\Framework\Error 来注释 PHPUnit\Framework\Error\Notice 和 PHPUnit\Framework\Error\Warning 分别代表 PHP 通知与 PHP 警告。 如果测试依靠会触发错误的 PHP 函数，例如 fopen ，有时候在测试中使用错误抑制符会很有用。通过抑制住错误通知，就能对返回值进行检查，否则错误通知将会导致抛出 PHPUnit\Framework\Error\Notice。 对异常进行测试是越明确越好的。对太笼统的类进行测试有可能导致不良副作用。因此，不再允许用 @expectedException 或 setExpectedException() 对 Exception 类进行测试。 测试的功能或代码, 编写的测试运行后断言肯定会抛出异常,可以用@expectException指定抛出的异常类型;如果抛出异常类型同注释异常类型一致,结果为测试成功; @expectedExceptionCode (异常错误码)、@expectedExceptionMessage (异常信息)和 @expectedExceptionMessageRegExp (异常信息正则匹配) 详细使用参考: 手册 对输出进行测试(echo等)如echo, print. 单元测试使用输出缓冲区控制方式获取此内容 详见手册 方法:手册 手册 phpunit可生成日志(搭配Xdebug)文档 基镜(测试基础环境)在执行测试时,有时需要预先搭建测试环境.类似于php的魔术方法行为; 手册 测试替身 桩件 在桩件中,创建测试所需要的对象,所需要的对象可能依赖或者创建复杂使用难度高 有时候对被测系统(SUT)进行测试是很困难的，因为它依赖于其他无法在测试环境中使用的组件。这有可能是因为这些组件不可用，它们不会返回测试所需要的结果，或者执行它们会有不良副作用。在其他情况下，我们的测试策略要求对被测系统的内部行为有更多控制或更多可见性。 使用桩件可以替换掉被测试系统所依赖的实际组件;返回配置好返回值的测试替身(桩件)的方法称为上桩; 可以固定简单返回值,也可以使用变量实现更复杂的上桩willReturn($value) or will($this-&gt;returnValue($value)) 返回对桩件对象的引用will($this-&gt;returnSelf()); 不同参数对应的不同返回值方式上桩returnValueMap(array $map); 让上桩方法返回回调函数或方法的结果returnCallback(); 直接给出期望返回值的列表will($this-&gt;onConsecutiveCalls(2, 3, 5, 7));调用顺序返回 抛出异常will($this-&gt;throwException(new Exception)); 仿件对象 使用仿件对象，主要的功能是验证预期的行为，作为观察点来核实被测试系统在测试中的间接输出。 方法的执行次数expects($this-&gt;once())-&gt;method(&#39;update&#39;) 传入方法的参数with($this-&gt;equalTo(&#39;something&#39;)); 对特质(Trait)与抽象类进行模仿 对 Web 服务(Web Services)进行上桩或模仿 对文件系统进行模仿 12345678910public function testMockBuy()&#123; $appleMock = $this-&gt;getMockBuilder(Apple::class) -&gt;setMethods(['getPrice', 'buy']) -&gt;getMock(); //建立预期情况，buy方法会被调用一次 $appleMock-&gt;expects($this-&gt;once()) -&gt;method('buy'); $this-&gt;custom-&gt;buy($appleMock, 10);&#125; 文档地址]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>phpunit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpstorm珍藏常用快捷键]]></title>
    <url>%2F%2Fnote%2Fphpstorm-collection-common-shortcuts.html</url>
    <content type="text"><![CDATA[设置项 自动定位 (定位编辑文件所在的位置) Project面板，工具图标按钮（齿轮形状），弹出的菜单中选择 Autoscroll from Source 编辑文件时，左侧文件夹聚焦到该文件 手动定位-快捷键 在编辑的所选文件按ALT+F1, 然后选择PROJECT VIEW(新版下一级 Project) PHP手册 Preferences -&gt; Tools-&gt;External Tools Parameters参数 http://php.net/manual/zh/function.$SelectedText$.php 注意： SelectedText 启动的时候不打开工程文件 Preferences-&gt;Appearance &amp; Behavior -&gt;System Settings 去掉 Reopen last project on startup.up. 使用功能 语法分析 Inspect Code 语法分析非常有用 右击 文件夹或文件，在菜单中选择 Inspect Code，会弹出 让你选择是指定目录文件或者还是整个项目 常用代码片段 CTRL(cmd) + j能够快捷的输入常用的代码片段，类似vim的 snipMate，可以自定义代码片段 代码格式化 ctrl+alt+l代码格式化 Setting: Live Templates代码片断 https://laracasts.com/series/how-to-be-awesome-in-phpstorm 光标跳转 移动光标到当前所在代码的花括号开始位置 Ctrl + [ Option+Command+[ 移动光标到当前所在代码的花括号结束位置 Ctrl + ] Option+Command+] 行处理 删除光标所在行 或 删除选中的行. Ctrl + Y, Command+delete 递进式选择代码块,可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围. Ctrl + W , Option+↑ 在当前文件跳转到指定行处(代码报错跳转) Ctrl + G Command+L ⌘+L 类处理 显示当前类的层次结构(继承或实现接口层次结构) Ctrl + H Control + H 选择可重写的方法(接口方法) Ctrl + O Control + O 选择可继承的方法 Ctrl + I Control + I 根据输入的 类名 查找类文件 Ctrl + N Command+O ⌘+O 进入光标所在的方法/变量的接口或是定义出 (预测返回值,详细类型) Ctrl + B或 Ctrl + 左键单击 Command + B 或 Command + 左键单击 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选 Ctrl + F12 Command+F12 查找//@todo标签 Alt + 6 Command+6 显示类中的方法(左下角显示) Alt + 7 Command+7 显示类中的方法 Alt + 8 Command+8 代码自动生成， 如生成对象的 set / get 方法， 构造函数，toString() 等 (get成员属性) Alt + Insert Control+Enter 或 Command+N 代码块 智能分隔行(左侧小灯泡实现) Ctrl + Enter Option+Enter 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的(左侧小灯泡实现)结果也不同 Alt + Enter Option+Enter 展开代码 Ctrl + + 折叠代码 Ctrl + - 选中文本， 逐个往下查找相同文本，并高亮显示 Alt + F3 Command+F 退回到上一个操作的地方 （必备） Ctrl + Alt + 左方向键 Option+Command+← 前进到上一个操作的地方 （必备） Ctrl + Alt + 右方向键 Option+Command+→ 注释 设置中搜索show quick document 鼠标移过将会显示定义时的注释 Ctrl(cmd) + /，单行注释 Ctrl(cmd) + Shift + /，多行注释,块注释 /** + Enter，自动生成注释 工作区 刷新工作区目录 当有新文件,idea并没有显示就需要手动刷新 在Save All旁边的按钮Synchronize按钮(Mac)option+command+Y (win)可能是ctrol+alt+Y 本文内容部分来源:https://blog.csdn.net/fenglailea/article/details/53350080?utm_source=copy]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>利器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端cdn失效修复]]></title>
    <url>%2F%2Fnote%2Ffrontend-cdn-failure-repair.html</url>
    <content type="text"><![CDATA[前端cdn失效修复 博客出现访问卡死现象,排查一下发现https://cdn.bootcss.com/的访问卡住,导致页面白屏等待资源加载 将https://cdn.bootcss.com/替换为https://cdnjs.cloudflare.com/ajax/libs/]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>容易疏忽的问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql查询设置大小写敏感以及性能(explain)对比]]></title>
    <url>%2F%2Fnote%2Fmysql-query-sets-case-sensitivity-and-performance-explain-comparison.html</url>
    <content type="text"><![CDATA[受到 此文 某些似懂非懂话语影响而折腾的笔记 解决方法: 查询时加上binaryexplain 分析 sql语句其中type有变动(sk已加上索引) type值解析 而不加binary 不区分大小写时 查询时强制二进制对比，尤其不好，这会让你代码中多出很多判断，且还有可能被绕过。至于直接使用二进制字段，mysql不会将它当成字符来处理，我觉得也可能存在问题。 字段建立时指定字符类型点我查看 建立时的字符类型 使用utf8_bin select * from api_key where sk = &#39;Gsxg583i+JhD4nHFCroeLKlMpUAI0XV9Rzjf6YqO_1Svy7QZkmw2PB&#39; Select 语句可以区分大小写 执行效率: explain select * from api_key where sk = &#39;GSxg583i+JhD4nHFCroeLKlMpUAI0XV9Rzjf6YqO_1Svy7QZkmw2PB&#39; 使用BINARY `select * from api_key where sk = &apos;Gsxg583i+JhD4nHFCroeLKlMpUAI0XV9Rzjf6YqO_1Svy7QZkmw2PB&apos;` Select 语句可以区分大小写 执行效率: `explain select * from api_key where sk = &apos;GSxg583i+JhD4nHFCroeLKlMpUAI0XV9Rzjf6YqO_1Svy7QZkmw2PB&apos;` 数据库创建时修改方式1方式2 laravel 数据库迁移解决方案12345678910public function up()&#123; Schema::create(&apos;api_key&apos;, function (Blueprint $table) &#123; //一堆建表语句 &#125;); //创建表成功后添加大小写敏感 DB::statement(&quot;alter table api_key modify column ak varchar(255) BINARY DEFAULT &apos;&apos; NOT NULL COMMENT &apos;as&apos;&quot;); DB::statement(&quot;alter table api_key modify column sk varchar(255) BINARY DEFAULT &apos;&apos; NOT NULL COMMENT &apos;as&apos;&quot;);&#125; 最终得出以上更改其实本质上也是把collatioin(校对)模式改成二进制校对，实现大小写敏感。 索引长度在判断大小写时会增加1,但是type会变成ref; 附给细心同学的懒人链接:key_len 参考资料:https://www.cnblogs.com/sonofelice/p/6432986.htmlhttp://cevin.net/archives/让mysql查询区分大小写.htmlhttps://blog.csdn.net/dennis211/article/details/78170079https://www.cnblogs.com/yuyue2014/p/3700531.htmlhttps://www.cnblogs.com/clphp/p/5403215.html]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>容易疏忽的问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php二维数组数据指定键唯一合并]]></title>
    <url>%2F%2Ftechnology-php%2Fphp-twodimensional-array-data-specified-key-unique-merge.html</url>
    <content type="text"><![CDATA[例子: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546array:11 [ 0 =&gt; array:2 [ "publicadtype" =&gt; "h5-zmiti" "num" =&gt; 16 ] 1 =&gt; array:2 [ "publicadtype" =&gt; "图片-zmiti" "num" =&gt; 88 ] 2 =&gt; array:2 [ "publicadtype" =&gt; "视频-zmiti" "num" =&gt; 13 ] 3 =&gt; array:2 [ "publicadtype" =&gt; "音频-zmiti" "num" =&gt; 30 ] 4 =&gt; array:2 [ "publicadtype" =&gt; "视频-zmiti" "notaudit" =&gt; 4 ] 5 =&gt; array:2 [ "publicadtype" =&gt; "h5-zmiti" "trial" =&gt; 16 ] 6 =&gt; array:2 [ "publicadtype" =&gt; "图片-zmiti" "trial" =&gt; 88 ] 7 =&gt; array:2 [ "publicadtype" =&gt; "视频-zmiti" "trial" =&gt; 8 ] 8 =&gt; array:2 [ "publicadtype" =&gt; "音频-zmiti" "trial" =&gt; 27 ] 9 =&gt; array:2 [ "publicadtype" =&gt; "视频-zmiti" "initialfailure" =&gt; 1 ] 10 =&gt; array:2 [ "publicadtype" =&gt; "音频-zmiti" "thefinal" =&gt; 3 ]] 将此数组变为: 12345678910111213141516171819202122232425array:4 [ 0 =&gt; array:3 [ "publicadtype" =&gt; "h5-zmiti" "num" =&gt; 16 "trial" =&gt; 16 ] 1 =&gt; array:3 [ "publicadtype" =&gt; "图片-zmiti" "num" =&gt; 88 "trial" =&gt; 88 ] 2 =&gt; array:5 [ "publicadtype" =&gt; "视频-zmiti" "num" =&gt; 13 "notaudit" =&gt; 4 "trial" =&gt; 8 "initialfailure" =&gt; 1 ] 3 =&gt; &amp; array:4 [ "publicadtype" =&gt; "音频-zmiti" "num" =&gt; 30 "trial" =&gt; 27 "thefinal" =&gt; 3 ]] 可用代码: 123456789101112131415$json = '[&#123;"publicadtype":"h5-zmiti","num":16&#125;,&#123;"publicadtype":"\u56fe\u7247-zmiti","num":88&#125;,&#123;"publicadtype":"\u89c6\u9891-zmiti","num":13&#125;,&#123;"publicadtype":"\u97f3\u9891-zmiti","num":30&#125;,&#123;"publicadtype":"\u89c6\u9891-zmiti","notaudit":4&#125;,&#123;"publicadtype":"h5-zmiti","trial":16&#125;,&#123;"publicadtype":"\u56fe\u7247-zmiti","trial":88&#125;,&#123;"publicadtype":"\u89c6\u9891-zmiti","trial":8&#125;,&#123;"publicadtype":"\u97f3\u9891-zmiti","trial":27&#125;,&#123;"publicadtype":"\u89c6\u9891-zmiti","initialfailure":1&#125;,&#123;"publicadtype":"\u97f3\u9891-zmiti","thefinal":3&#125;]';$data = json_decode($json, true);foreach ($data as $nk =&gt; &amp;$nv) &#123; foreach ($data as $nnk =&gt; $nnv) &#123; if ($nk !== $nnk) &#123; if (in_array($nv['publicadtype'], $nnv)) &#123; $nv = array_merge($nv, $nnv); if ($nnk !== $nk) &#123; unset($data[$nnk]); &#125; &#125; &#125; &#125;&#125; ps:此代码有一个重复赋值找出修改方法吧 数组复杂处理常见的引用符号,加上后有些重复处理和赋值会直接操作原有数组.]]></content>
      <categories>
        <category>PHP技术栈</category>
      </categories>
      <tags>
        <tag>解决问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码习惯-2019.06.03]]></title>
    <url>%2F%2Fnote%2Fcoding-habit-20190603.html</url>
    <content type="text"><![CDATA[本文档长期不定时更新 在使用get()或者select() 查询列表时,要么分页,要么limit限制最大长度 在使用return 时尽量只有一个return 方便查阅; 在编写类时,注意单一职责; 变量尽量在有必要提前存在时才声明 php是弱类型语言,对数据记得做类型校验 对方法参数做类型约束 数据库状态或数字代表含义的, 放在配置文件然后调取语义化配置使用,方便查阅 不使用is_系列函数,使用全等替换 减少使用= = 而去使用=== 案例 在c中i++只需要一条cpu指令, 一直以为$i++的效率很高, 但是我看到的框架(比如tp)都没用使用$i++, 而是使用$i += 1, 在php中$i++需要4条opcodes 编写或调用缓存时 注意:命中 (Hit) - 一个缓存的命中，指的是当调用类库使用「键」在请求一个缓存项的时候，在缓存池里能找到对应的缓存项，并且此缓存项还未过期，并且此数据不会因为任何原因出现错误。调用类库 应该 确保先验证下 isHit() 有命中后才调用 get() 获取数据。 参考 前后端分离返回数据的参数键命名分隔时,尽量使用下划线分隔 在laravel模型通过属性获取模型关联数据数据如果这个字段有可能不存在的 使用isset判断 或使用 ?? ‘’ 编写权限或者状态时预留方法 返回可用账户的where组合 按照单一职责原则，一个类只应该关心自己的逻辑，当出现问题的时候，如果不是当前类该处理的，我们就应该抛出而不是消化。 业务异常与运行时异常要区分开 一个类只干自己相关的事情，比如通知类不要去关心 SMTP 如何构造。 一个方法只干一件事儿，如何定义呢？当你给方法起名的时候纠结了，那你的方法设计得就有问题了，getUserById，getUsers 这些肯定就是只干了一件事儿。 命名要见名知义，动名词格式命名。少用 info，data 这类无意义词，比如 getUserInfo 完全可以叫 getUser。getOrdersData，getOrdersList 也完全可以写为 getOrders。 一个方法尽量不要超过 30 行；]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>编码习惯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端翻译国际化]]></title>
    <url>%2F%2Ftechnology-web%2Ffrontend-translation-internationalization.html</url>
    <content type="text"><![CDATA[标签（空格分隔）： 网站国际化支持 在网站中加入: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;script&gt; var langPackage = &#123; &quot;主题&quot;: &quot;Title&quot;, &quot;下一页&quot;: &quot;NextPage&quot;, &quot;末页&quot;: &quot;LastPage&quot;, &quot;首页&quot;: &quot; FirstPage &quot;, &quot;上一页&quot;: &quot; PreviousPage &quot;, &quot;待办工作&quot;: &quot;MyTasks&quot;, &quot;中&quot;: &quot;Middle&quot;, &quot;每页&quot;: &quot; EachPage &quot;, &quot;条&quot;: &quot; Record &quot;, &quot;共&quot;: &quot; Total &quot;, &quot;页&quot;: &quot; Page &quot;, &quot;第&quot;: &quot; Current &quot;, &quot;工作主题&quot;: &quot; ProcTitle&quot; &#125;; /* 主调函数 在 Jquery的 .read方法里调用 ReplaceChildChs($(document)); 或者页面的最后调用 ReplaceChildChs($(document)); */ function ReplaceChildChs(nodeObj) &#123; // if($(&quot;#hdfUseLang&quot;).val()==&quot;CN&quot;)return; if (nodeObj.children().length &gt; 0) &#123; nodeObj.children().each(function() &#123; ReplaceChildChs($(this)); // if ($(this)[0].nodeName.toUpperCase() == &quot;TD&quot;)&#123; FindChsAndReplaceIt($(this)); // &#125; &#125;); &#125; else &#123; FindChsAndReplaceIt(nodeObj); &#125; &#125; // 直接替换html 的一种设想，但总是报错 function JustReplaceChsDom(nodeObj) &#123; var pat = new RegExp(&quot;[\u4e00-\u9fa5]+&quot;, &quot;g&quot;); // 匹配中文的正则表达式 var str = $(nodeObj).html(); while ((arr = pat.exec(str)) != null) &#123; if (langPackage[arr[0]]) &#123; str = str.replace(arr[0], langPackage[arr[0]]); &#125; &#125; $(nodeObj).html(str); &#125; function FindChsAndReplaceIt(nodeObj) &#123; var pat = new RegExp(&quot;[\u4e00-\u9fa5]+&quot;, &quot;g&quot;); if ((nodeObj.text() || nodeObj.val() || nodeObj.attr(&quot;title&quot;)) &amp;&amp; (pat.exec(nodeObj.text()) || pat.exec(nodeObj.val()) || pat.exec(nodeObj.attr(&quot;title&quot;)))) &#123; var str = &quot;&quot; if (nodeObj.text()) &#123; str = nodeObj.text(); ReplaceValue(str, nodeObj, &quot;text&quot;); &#125; if (nodeObj.val()) &#123; str = nodeObj.val(); ReplaceValue(str, nodeObj, &quot;val&quot;); &#125; if (nodeObj.attr(&quot;title&quot;)) &#123; str = nodeObj.attr(&quot;title&quot;); ReplaceValue(str, nodeObj, &quot;title&quot;); &#125; &#125; &#125; function ReplaceValue(str, nodeObj, attrType) &#123; var arr; var pat = new RegExp(&quot;[\u4e00-\u9fa5]+&quot;, &quot;g&quot;); while ((arr = pat.exec(str)) != null) &#123; if (langPackage[arr[0]]) &#123; str = str.replace(arr[0], langPackage[arr[0]]); if (attrType == &quot;text&quot;) &#123; nodeObj.text(str); &#125; else if (attrType == &quot;val&quot;) &#123; nodeObj.val(str); &#125; else if (attrType == &quot;title&quot;) &#123; nodeObj.attr(&quot;title&quot;, str); &#125; &#125; &#125; &#125; ReplaceChildChs($(document));&lt;/script&gt; 上面数组进行单词替换;文章啥的最好还是有多语言的支持 translate翻译方式 需要翻墙123456789101112131415161718&lt;div id=&quot;google_translate_element&quot;&gt;&lt;/div&gt;&lt;script&gt; function googleTranslateElementInit() &#123; new google.translate.TranslateElement(&#123; pageLanguage: &apos;zh-CN&apos;, layout: google.translate.TranslateElement.InlineLayout.SIMPLE &#125;, &apos;google_translate_element&apos;); &#125;&lt;/script&gt;&lt;script src=&quot;//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit&quot;&gt;&lt;/script&gt;&lt;!-- Begin TranslateThis Button --&gt;&lt;div id=&quot;translate-this&quot;&gt;&lt;a href=&quot;http://translateth.is/&quot; class=&quot;translate-this-button&quot;&gt;Translate&lt;/a&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.google.com/jsapi&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://x.translateth.is/translate-this.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; TranslateThis();&lt;/script&gt;&lt;!-- End TranslateThis Button --&gt;]]></content>
      <categories>
        <category>前端技术栈</category>
      </categories>
      <tags>
        <tag>i18n</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rtmp流媒体 nginx服务端搭建]]></title>
    <url>%2F%2Fmo-ren-fen-lei%2Frtmp-streaming-nginx-server-build.html</url>
    <content type="text"><![CDATA[rtmp流媒体 nginx服务端搭建标签（空格分隔）： 直播 mkdir nginx 切换到nginx目录，下载压缩包并解压到当前工作目录： wget http://nginx.org/download/nginx-1.12.1.tar.gz tar -zxvf nginx-1.12.1.tar.gz 安装依赖的的库： sudo apt-get install libssl-dev libpcre3-dev zlib1g-dev 下载rtmp模块，生成目录nginx-rtmp-module： git clone https://github.com/arut/nginx-rtmp-module.git 切换到nginx-1.12.1目录，执行（如果想build调试版本的话，要添加–with-debug）： ./configure –add-module=/home/sunrayme/nginx/nginx-rtmp-modulemake sudo make install 运行nginx： sudo /usr/local/nginx/sbin/nginx ffmpeg -f dshow -i video=”BisonCam, NB Pro”:audio=”麦克风 (Realtek High Definition Audio)” -vcodec libx264 -acodec copy -preset:v ultrafast -tune:v zerolatency -f flv “rtmp://p855c26b6.live.126.net/live/685f6451704349a8bed4489f170d4084?wsSecret=1e0357b0ce7e101ac0613396148ae2b4&amp;wsTime=1523430887” netstat -ntlp 查看端口占用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;rtmp &#123; server &#123; listen 1935; #监听的端口 chunk_size 4000; application myapp &#123; live on; &#125; application hls &#123; #rtmp推流请求路径 live on; hls on; hls_path /tmp/hls; hls_fragment 3s; &#125; &#125; &#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 8080; #charset koi8-r; #access_log logs/host.access.log main; location /state &#123; rtmp_stat all; rtmp_stat_stylesheet stat.xsl; &#125; location /stat.xsl &#123; root /vagrant_date/nginx-rtmp-module-master; &#125; &#125; server &#123; listen 81; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; #加入hls支持 location /hls &#123; types &#123; application/vnd.apple.mpegurl m3u8; #或 application/x-mpegURL video/mp2t ts; &#125; alias /tmp/hls; #视频流文件目录(自己创建) expires -1; add_header Cache-Control no-cache; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 配置文件验证 /usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf ffmpeg -f dshow -i video=”BisonCam, NB Pro”:audio=”麦克风 (Realtek High Definition Audio)” -vcodec libx264 -acodec copy -preset:v ultrafast -tune:v zerolatency -f flv “rtmp://192.168.1.113/live live=1” rtmp://192.168.1.113:1935/hls/testrtmp://192.168.1.113:1935/myapp/testhls 加上mp4flv播放和清缓存 ./configure –with-http_ssl_module –add-module=../nginx-rtmp-module –with-http_v2_module –with-http_ssl_module –with-http_sub_module –with-http_stub_status_module –with-http_gzip_static_module –with-pcre 1./configure --prefix=/usr/local/nginx/ --add-module=../nginx-rtmp-module --add-module=../ngx_cache_purge-master --with-http_stub_status_module --with-http_ssl_module --with-http_sub_module --with-http_gzip_static_module --with-http_mp4_module --with-http_flv_module yum -y install pcre-devel openssl openssl-devel 有时候，我们需要单独安装nginx，来处理大量的下载请求。单独在Centos5安装nginx遇到的rewrite和HTTP cache错误解决办法： wget http://nginx.org/download/nginx-0.8.33.tar.gztar -zxvf nginx-0.8.33.tar.gzcd nginx-0.8.33./configure –prefix=/usr/local/nginx 安装Nginx时报错 ./configure: error: the HTTP rewrite module requires the PCRE library. 安装pcre-devel解决问题yum -y install pcre-devel 错误提示：./configure: error: the HTTP cache module requires md5 functionsfrom OpenSSL library. You can either disable the module by using–without-http-cache option, or install the OpenSSL library into the system,or build the OpenSSL library statically from the source with nginx by using–with-http_ssl_module –with-openssl= options. 解决办法： yum -y install openssl openssl-devel 总结： yum -y install pcre-devel openssl openssl-devel ./configure –prefix=/usr/local/nginx make make install 昌书电脑安装记录 nginx path prefix: “/usr/local/nginx/“ nginx binary file: “/usr/local/nginx//sbin/nginx” nginx modules path: “/usr/local/nginx//modules” nginx configuration prefix: “/usr/local/nginx//conf” nginx configuration file: “/usr/local/nginx//conf/nginx.conf” nginx pid file: “/usr/local/nginx//logs/nginx.pid” nginx error log file: “/usr/local/nginx//logs/error.log” nginx http access log file: “/usr/local/nginx//logs/access.log” nginx http client request body temporary files: “client_body_temp” nginx http proxy temporary files: “proxy_temp” nginx http fastcgi temporary files: “fastcgi_temp” nginx http uwsgi temporary files: “uwsgi_temp” nginx http scgi temporary files: “scgi_temp” 编译时出现 set but not used [-Werror=unused-but-set-variable] 问题的解决办法： 找到对应目录(nginx中)中的Makefile文件，找到 -Werror 字段，去掉-Werror，重新编译，则问题解决 rtmp://p855c26b6.live.126.net/live/685f6451704349a8bed4489f170d4084?wsSecret=aec4eda8a73a12c2dd525319608bf533&amp;wsTime=1523520333 rtmp://192.168.1.119:1935/myapp/test rtmp://192.168.1.119:1935/myapp/test rtmp://192.168.1.119:1935/hls/test http://111.231.138.185:81/hls/test #user nobody;worker_processes 2; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024;} http { include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 8080; #charset koi8-r; #access_log logs/host.access.log main; location /state { rtmp_stat all; rtmp_stat_stylesheet stat.xsl; } location /stat.xsl { root /vagrant_date/nginx-rtmp-module-master; } } server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; #加入hls支持 location /hls { types { application/vnd.apple.mpegurl m3u8; #或 application/x-mpegURL video/mp2t ts; } alias /tmp/hls; #视频流文件目录(自己创建) expires -1; add_header Cache-Control no-cache; } }} rtmp_auto_push on; #因为Nginx可能开启多个子进程，这个选项表示推流时，媒体流会发布到多个子进程 rtmp { server { listen 1935; #监听的端口 chunk_size 4000; application myapp { live on; } application hls { #rtmp推流请求路径 live on; hls on; hls_path /tmp/hls; hls_fragment 3s; #每个视频切片的时长 hls_playlist_length 0s; #总共可以回看的事件，这里设置的是1分钟。 hls_continuous on; #连续模式。 hls_cleanup on; #对多余的切片进行删除。 hls_nested on; #嵌套模式。 } }}]]></content>
      <categories>
        <category>默认分类</category>
      </categories>
      <tags>
        <tag>rtmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地网络 远程访问 frp内网穿透]]></title>
    <url>%2F%2Fnote%2Flocal-network-remote-access-frp-intranet-penetration.html</url>
    <content type="text"><![CDATA[标签： 内网穿透 初衷在早前建站时,想过使用本地架设服务端,让远程访问到本地网站端口. 想法遇到的问题 在本地架设服务端,需要有一台可以作网站解析的电脑(并且长期在线); 需要有公网ip,按照国内运营商的尿性,以及自己的打探 因为公网ip资源紧缺,国内的网络基本属于 一群小弟(我们买的宽带) 希望看场子(访问广域网) 但是小弟必须去请求老大(宽带提供商),去分配给你一个公网ip 如果运营商客气一般能直接开(这篇文章对你没用了),如果不客气要么需要一系列手续,更或者直接说家用宽带没有公网ip; 解决思路 这些问题中第一个想想就感觉有些吃力,但是目前我使用的方案是从网上买个树莓派,在家里一直挂着(树莓派3 5v2A=10w，一天24小时=0.24度电，一个月4元,加上路由器的 4 元一个月大概8元[能接受]) 公网ip这个可以通过自己的服务器有一个公网ip解决 (撸学生云大概是50多半年[最多]),然后使用本篇文章提供的内网穿透教程,就可以好好玩了; 内网穿透教程拉轮子我从网上看了一些老的教程,跟新的版本使用并没有多少出入,所以本文可以放心实验; 下载frp客户端和服务端:传送门(32位为386,64位为amd64) 准备一个客户端,一个服务端(具备公网ip的服务器或主机); 使用轮子下载 下载windows版本,最下边(32位为386,64位为amd64) 服务端也下载安装对应系统的版本 我这次使用的是linux的服务端,不同系统配置都差不多,继续看下去; 目录解析windows下载后文件夹是这样的 Linux下载解压(网上有教程)后是这样的是不是差不多; 配置也差不多; 可以单独这样 frp 后面加上 s 的是服务端, c 是客户端 如果有公网IP 将frps和frps.ini添加到您的服务器。 将frpc和frpc.ini放到您局域网中的服务器上。 案例通过公网ip的7000端口,访问您的计算机的80端口 配置服务端: 修改frps.ini： 123[common]bind_port = 7000 #绑定7000vhost_http_port = 8080 # 绑定8080 为http服务端口 开启服务端: linux: 1./frps -c ./frps.ini windows 打开cmd(右键左下角windows图标,点击运行输入cmd确定)然后切换到程序所在目录; 你可能碰到的一些命令: cd ..切换到上级目录如C:\Users\qiaoanqiao使用该命令会到C:\Users dir 显示当前目录中的文件夹和文件,后面跟上目录显示这个目录中的文件夹或文件 E: 盘符号加上一个冒号,切换盘符. 经过一系列命令,我可以假设你到了这个程序的解压后目录,然后也是执行 1./frps -c ./frps.ini 配置客户端: 修改frpc.ini，server_addr是你frps(服务端)公网IP： 12345678[common]server_addr = x.x.x.x #指定服务端的公网ipserver_port = 7000 #指定服务端的内网穿透软件监听端口[web] type = http #类型 http,还有tcp udplocal_port = 80 #本地端口custom_domains = www.yourdomain.com #访问过来的域名 客户端打开: 1./frpc -c ./frpc.ini 然后 域名www.yourdomain.com将IP x.x.x.x或CNAME记录的记录值解析到您的域名。浏览器访问 http://www.yourdomain.com:8080 还有更多实例请参考:传送门]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vagrant使用记录]]></title>
    <url>%2F%2Fnote%2Fvagrant-usage-record.html</url>
    <content type="text"><![CDATA[标签（空格分隔）： vagrant 看本文首先你要对vagrant有一定了解 传送门 从网上搜索国内镜像源,他们说官方有cdn那就从官方搜索下载了 Vagrant 就是使用 Ruby 写成的, 所以在这里的配置文件也需要满足 Ruby 语法。 config.vm.box = “ubuntu/trusty64”可以看到，这两行就是我们在vagrant init中后面所指定的参数。由此可以看出，vagrant init只是帮我们生成了配置文件而已，换句话说，如果我们写好了Vagrantfile，就不需要vagrant init，只需将准备好的配置文件放入到所需目录中，然后直接执行vagrant up即可。 还有很多注释掉的配置，那些都是一些常用的配置，包括网卡设置、IP地址、绑定目录，甚至可以指定内存大小、CPU个数、是否启动界面等等。如果需要，可以根据注释文本进行配置。 下面列出一些常用的配置： config.vm.hostname：配置虚拟机主机名 config.vm.network：这是配置虚拟机网络，由于比较复杂，我们其后单独讨论 config.vm.synced_folder：除了默认的目录绑定外，还可以手动指定绑定 config.ssh.username：默认的用户是vagrant，从官方下载的box往往使用的是这个用户名。如果是自定制的box，所使用的用户名可能会有所不同，通过这个配置设定所用的用户名。 config.vm.provision：我们可以通过这个配置在虚拟机第一次启动的时候进行一些安装配置，后面我们将专门介绍。需要注意的是，Vagrantfile文件只会在第一次执行vagrant up时调用执行，其后如果不明确使用vagrant reload，则不会被强制重新加载。 config.vm.network”forwarded_port”,guest:80,host:8080这将让物理机的8080端口映射到虚拟机的80端口。因此，可以在物理机上直接访问虚拟机所建立的网站。这在虚拟机使用不是桥接的时候尤为重要，因为很多时候默认会禁止物理机通过网络直接访问虚拟机，通过端口映射可以依旧能够访问所需端口。 我们还可以通过config.vm.network来指定所在网络以及IP地址。一般来说，分为private_network还是public_network。 private_network： 私有网络位于私有网络的主机之间可以互相访问，但是外界无法访问私有网络的主机，对于某些虚拟机而言，连物理机都无法通过网络直接访问虚拟机，此时如果需要使用物理机访问虚拟机，就需要前面所提及的端口映射。例如： config.vm.network&quot;private_network&quot;,ip:&quot;192.168.33.10&quot;public_network：公有网络在绝大多数虚拟机上，这等同于桥接网络。如果虚拟机选择了桥接方式连接，也就是相当于虚拟机和物理机在网络上处于平等的位置，同样的接在了网卡所在的网络。因此从外界看来，会感觉这是两台独立的计算机。 配置方式和私有网络接近，只需将其中的private_network换成public_network。如要使用 DHCP： config.vm.network&quot;public_network&quot;如果物理机存在多块网卡，需要指定某一块作为桥接用，那么可以参考如下配置： config.vm.network&quot;public_network&quot;,:bridge=&gt;&apos;en1: Wi-Fi (AirPort)&apos;如果是在启动了虚拟机之后，需要重新加载配置，只需要执行： vagrant reload vagrant基本命令，根据操作的目的，可以对基本命令进行分类：1 操作镜像box package2 操作虚拟机connect destroy halt init powershell provision rdp reload resume share snapshot ssh suspend up3 监控虚拟机global-status ssh-config port status4 其他help login plugin push version 1 操作镜像该命令有两个，用来管理本地镜像1.1 vagrant box1.1.1 添加镜像到本地仓库$ vagrant box add [box-name] [box镜像文件或镜像名] 1.1.2 移除本地镜像$ vagrant box remove [box-name] box多版本共存的情况如果box升级过，那么在box list中会出现两个同名，但版本不同的镜像。如：$ vagrant box list |grep coreoscoreos-alpha (virtualbox, 745.1.0)coreos-alpha (virtualbox, 928.0.0) 使用该镜像创建虚拟机的时候，默认会使用高版本的box。如果想使用低版本，需要修改Vagrantfile,指定box-version在config.vm.box=xxx下一行，如上面的例子中，在“config.vm.box = “coreos-alpha””后面增加一行配置信息：config.vm.box_version = “745.1.0” 同样，如果想删除一个box，如下操作会失败：$ vagrant box remove coreos-alphaYou requested to remove the box ‘coreos-alpha’ with provider‘virtualbox’. This box has multiple versions. You mustexplicitly specify which version you want to remove withthe --box-version flag or specify the --all flag to remove allversions. The available versions for this box are: 745.1.0 928.0.0 这时有两个选择： vagrant box remove coreos-alpha –all删除所有同名镜像 vagrant box remove coreos-alpha –box-version=745.1.0删除指定版本的镜像 1.1.3 升级镜像检查镜像是否有升级？$ cd ~/vm/ubuntu$ vagrant box outdatedChecking if box ‘ubuntu/trusty64’ is up to date…A newer version of the box ‘ubuntu/precise64’ is available! You currentlyhave version ‘20160122.0.0’. The latest is version ‘20160209.0.0’. Runvagrant box update to update. 中央仓库有新版更新了，手动更新box。更新的结果并不是替换旧版本，而是在本地仓库中增加了新版的box镜像。$ cd ~/vm/ubuntu$ vagrant box update==&gt; default: Checking for updates to ‘ubuntu/precise64’ default: Latest installed version: 20160120.0.0 default: Version constraints: default: Provider: virtualbox==&gt; default: Updating ‘ubuntu/precise64’ with provider ‘virtualbox’ from version==&gt; default: ‘20160120.0.0’ to ‘20160201.0.0’…==&gt; default: Loading metadata for box ‘https://atlas.hashicorp.com/ubuntu/precise64?access_token=cXR0wCgWXoRpMw.atlasv1.ydBAS4ev1YCWzSK4S1l6iVjssRbO5Q50a8YVnEPqoyYjcQVeaMdEsiQ8rz8tOcSHLuY&#39;==&gt; default: Adding box ‘ubuntu/precise64’ (v20160201.0.0) for provider: virtualbox default: Downloading: https://atlas.hashicorp.com/ubuntu/boxes/precise64/versions/20160201.0.0/providers/virtualbox.box==&gt; default: Successfully added box ‘ubuntu/precise64’ (v20160201.0.0) for ‘virtualbox’! $ vagrant box list | grep precise64ubuntu/precise64 (virtualbox, 20160120.0.0)ubuntu/precise64 (virtualbox, 20160201.0.0) 也可以检查本地仓库中的所有镜像是否有升级,使用 –global 开关，这时候不需要进入工作目录$ vagrant box outdated –global ‘ubuntu/trusty64’ is outdated! Current: 20160122.0.0. Latest: 20160209.0.0 ‘ubuntu/precise64’ (v20160201.0.0) is up to date ‘pollyduan/bento_oracle_xe’ wasn’t added from a catalog, no version information ‘phusion/ubuntu-14.04-amd64’ (v2014.04.30) is up to date ‘hashicorp/precise32’ (v1.0.0) is up to date ‘hashicorp/boot2docker’ (v1.7.8) is up to date ‘debian/jessie64’ wasn’t added from a catalog, no version information ‘coreos-alpha’ is outdated! Current: 928.0.0. Latest: 955.0.0 ‘centos7’ wasn’t added from a catalog, no version information ‘centos65’ wasn’t added from a catalog, no version information ‘centos64’ wasn’t added from a catalog, no version information ‘bento/ubuntu-14.04’ (v2.2.3) is up to date ‘bento/opensuse-13.2-x86_64’ (v2.2.1) is up to date ‘bento/freebsd-10.2’ (v2.2.3) is up to date ‘bento/fedora-22’ (v2.2.3) is up to date ‘bento/debian-8.2’ (v2.2.3) is up to date ‘bento/centos-7.2’ (v2.2.3) is up to date ‘bento/centos-6.7’ (v2.2.3) is up to date 不进入工作目录进行升级$ vagrant box update –box coreos-alphaChecking for updates to ‘coreos-alpha’Latest installed version: 928.0.0Version constraints: &gt; 928.0.0Provider: virtualboxUpdating ‘coreos-alpha’ with provider ‘virtualbox’ from version‘928.0.0’ to ‘955.0.0’…Loading metadata for box ‘http://alpha.release.core-os.net/amd64-usr/current/coreos_production_vagrant.json&#39;Adding box ‘coreos-alpha’ (v955.0.0) for provider: virtualboxDownloading: http://alpha.release.core-os.net/amd64-usr/955.0.0/coreos_production_vagrant.boxBox download is resuming from prior download progressProgress: 1% (Rate: 92912/s, Estimated time remaining: 0:38:09)… 1.2 打包镜像创建vm以后，我们自己根据需要安装软件，配置环境，都一切就绪了。如何分发给小伙伴使用呢？这里就要涌到package命令了，把镜像打包分发。$ ll ~/VirtualBox\ VMs/ |grep ubuntudrwx—— 6 pollyduan staff 204 2 2 11:18 ubuntu_default_1453944793418_7699先看一下我们的vm目录名，这里有个容易混淆的目录： Vagrantfile所在的目录——vagrant的工作目录 虚拟机文件所在的目录——virtualbox的工作目录这两个目录名不一定相同，如果在Vagrantfile中指定了vb.name，virtualbox工作目录就取这个名字；否则，命名为：vagrant工作目录_随机字符串。或者，也可以使用virtual box的管理工具来看vm的名称。 $ VBoxManage list vms|grep ubuntu“ubuntu_default_1453944793418_7699” {0362edc2-548b-400b-a55d-776b0a24cd8d} package命令要使用的是virtual box工作目录。 格式：vagrant package –base [virtualbox的工作目录] –output [保存的文件名，缺省为package.box] $ vagrant package –base ubuntu_default_1453944793418_7699 –output ubuntu_myproject_test.box==&gt; ubuntu_default_1453944793418_7699: Clearing any previously set forwarded ports…==&gt; ubuntu_default_1453944793418_7699: Exporting VM…==&gt; ubuntu_default_1453944793418_7699: Compressing package to: /Users/pollyduan/vm/tmp/ubuntu_myproject_test.box 导出后，可以通过IM、ftp或其他方式分发给小伙伴，那么大家使用的环境就是一致的了。 2 操作虚拟机 2.1 启动vm 2.1.1 对于单虚拟机$ vagrant up 2.1.2 如果同一个Vagrantfile定义了一个以上的虚拟机，则：$ vagrant up [vm-name]其他命令类似。如果省略vm-name，则依次启动所有vm。 2.2 重启$ vagrant reload [vm-name] 2.3 关机$ vagrant halt [vm-name] 2.4 销毁虚拟机$ vagrant destroy [vm-name] 2.5 ssh登录虚拟机$ vagrant ssh [vm-name] 2.6 休眠与唤醒这一对冤家也无需多说，对于开发环境来说，个人觉得用处不是很大。$ vagrant suspend==&gt; default: Saving VM state and suspending execution…$ vagrant statusCurrent machine states: default saved (virtualbox) To resume this VM, simply run vagrant up.$ vagrant resume==&gt; default: Resuming suspended VM…==&gt; default: Booting VM……… 2.7 快照vagrant snapshot命令是vm的月光宝盒，如果vm中有任务没有跑完，需要关闭virtual box，就可以给vm做一个快照，保存vm当前所有的状态，在virtualbox重新启动后，再回复快照。2.7.1 查看当前保存的快照$ vagrant snapshot list==&gt; default: No snapshots have been taken yet! 2.7.2 创建一个命名快照$ vagrant snapshot save shot1==&gt; default: Snapshotting the machine as ‘shot1’…$ vagrant snapshot listshot1 2.7.3 恢复快照$ vagrant snapshot restore shot1==&gt; default: Forcing shutdown of VM…==&gt; default: Restoring the snapshot ‘shot1’……… 恢复后，快照会一直存在，直到你手动删除它。 2.7.4 删除快照$ vagrant snapshot delete shot1==&gt; default: Deleting the snapshot ‘shot1’…Progress: 90%Progress: 100%==&gt; default: Snapshot deleted! 这个操作会删除持久化的数据文件，稍微有点慢，耐心等待。这个内在的原理没有深入研究，有点不太理解，删除一个文件理论上应该比保存一个文件更快才对。 2.7.5 盗梦空间push和pop，每调用一次push命令会自动创建一个命名快照，名为：push+一串随机数，如：push_1455524411_6632；每调用一次pop，会逐级恢复到最新的快照，并删除快照。看例子：$ vagrant snapshot list==&gt; default: No snapshots have been taken yet!$ vagrant snapshot push==&gt; default: Snapshotting the machine as ‘push_1455525041_2882’…$ vagrant snapshot listpush_1455525041_2882$ vagrant snapshot push==&gt; default: Snapshotting the machine as ‘push_1455525049_7456’…$ vagrant snapshot push==&gt; default: Snapshotting the machine as ‘push_1455525058_6891’…$ vagrant snapshot listpush_1455525041_2882push_1455525049_7456push_1455525058_6891$ vagrant snapshot pop==&gt; default: Forcing shutdown of VM…==&gt; default: Restoring the snapshot ‘push_1455525058_6891’…==&gt; default: Deleting the snapshot ‘push_1455525058_6891’…==&gt; default: Snapshot deleted!$ vagrant snapshot listpush_1455525041_2882push_1455525049_7456 Tips: 文本的日志看起来还不够形象，在push三个snapshot后在virtual box中是树形显示的；每次pop，树枝会逐级退回，看起来更像穿越的感觉。Tips: 在pop清空之前，随时可以通过restore恢复其中一个快照，同样快照不会删除；不影响pop的测试。 2.8 远程连接分享远程连接通过share connect两个命令可以实现通过本机vagrant连接另外一台host上的虚机。2.8.1 允许ssh连接$ vagrant share –ssh==&gt; default: Detecting network information for machine… default: Local machine address: 127.0.0.1 default: default: Note: With the local address (127.0.0.1), Vagrant Share can only default: share any ports you have forwarded. Assign an IP or address to your default: machine to expose all TCP ports. Consult the documentation default: for your provider (‘virtualbox’) for more information. default: default: An HTTP port couldn’t be detected! Since SSH is enabled, this is default: not an error. If you want to share both SSH and HTTP, please set default: an HTTP port with --http. default: default: Local HTTP port: disabled default: Local HTTPS port: disabled default: SSH Port: 2200 default: Port: 2200==&gt; default: Generating new SSH key… default: Please enter a password to encrypt the key: [输入授权密码] default: Repeat the password to confirm:[再输一次] default: Inserting generated SSH key into machine…==&gt; default: Checking authentication and authorization…==&gt; default: Creating Vagrant Share session… default: Share will be at: vile-ibex-8238==&gt; default: Your Vagrant Share is running! Name: vile-ibex-8238==&gt; default:==&gt; default: You’re sharing your Vagrant machine in “restricted” mode. This==&gt; default: means that only the ports listed above will be accessible by==&gt; default: other users (either via the web URL or using vagrant connect).==&gt; default:==&gt; default: You’re sharing with SSH access. This means that another user==&gt; default: simply has to run vagrant connect --ssh vile-ibex-8238==&gt; default: to SSH to your Vagrant machine.==&gt; default:==&gt; default: Because you encrypted your SSH private key with a password,==&gt; default: the other user will be prompted for this password when they==&gt; default: run vagrant connect --ssh. Please share this password with them==&gt; default: in some secure way. Tips: 你可以通过–name指定一个名称，否则会随机生成一个共享名，如本例中的vile-ibex-8238 2.8.2 连接远端ssh虚机$ vagrant connect –ssh vile-ibex-8238 –static-ip 10.2.136.211Loading share ‘vile-ibex-8238’…The SSH key to connect to this share is encrypted. You will requirethe password entered when creating to share to decrypt it. Verify youaccess to this password before continuing. Press enter to continue, or Ctrl-C to exit now.[回车]Password for the private key:[输入授权密码]Executing SSH…vagrant@vagrant-ubuntu-trusty-64:~$ 2.8.3 共享httpvagrant share可以把host主机的http开放到远端，供任何人访问，这好像跟vm没什么关系，但的确它发生了。$ ~/apache-tomcat-8.0.28/bin/startup.sh$ vagrant share –http 80==&gt; default: Detecting network information for machine… default: Local machine address: 127.0.0.1 default: default: Note: With the local address (127.0.0.1), Vagrant Share can only default: share any ports you have forwarded. Assign an IP or address to your default: machine to expose all TCP ports. Consult the documentation default: for your provider (‘virtualbox’) for more information. default: default: Local HTTP port: 80 default: Local HTTPS port: disabled default: Port: 2200==&gt; default: Checking authentication and authorization…==&gt; default: Creating Vagrant Share session… default: Share will be at: enchanting-buffalo-1493==&gt; default: Your Vagrant Share is running! Name: enchanting-buffalo-1493==&gt; default: URL: http://enchanting-buffalo-1493.vagrantshare.com==&gt; default:==&gt; default: You’re sharing your Vagrant machine in “restricted” mode. This==&gt; default: means that only the ports listed above will be accessible by==&gt; default: other users (either via the web URL or using vagrant connect). 我的host电脑在内网，在外网的任意一台电脑上，访问http://enchanting-buffalo-1493.vagrantshare.com，奇迹发生了。 话说这个有什么用呢？别忘记，vagrant有一个端口映射的功能，在后面的Vagrantfile配置里会提到，这样做的结果，就是可以在互联网任意一个角落可以访问到你的虚机的http服务。 2.9 windows相关的操作powershelgl和rdp是windows vm相关的操作，未做测试，忽略。 2.10 虚机环境部署provision用于通过Vagrantfile配置文件，对vm进行部署，如安装软件，发布应用等，在这里不多说，专门一章来记录。 2.11 指定vmid操作虚拟机在3.3.2中，我们可以看到当前工作机中的所有虚机，其中第一列数据为vmid，我们可以无需进入vagrant工作目录，操作这些虚机。如：$ vagrant up 63093ce 该方式适用于前面提到的up、reload、halt、destroy等命令。 3 监控虚拟机3.1 查看sshd配置信息$ vagrant ssh-configHost default HostName 127.0.0.1 User vagrant Port 2222 UserKnownHostsFile /dev/null StrictHostKeyChecking no PasswordAuthentication no IdentityFile “/Users/pollyduan/vm/ubuntu/.vagrant/machines/default/virtualbox/private_key” IdentitiesOnly yes LogLevel FATAL 3.2 查看虚拟机开放的端口$ vagrant portThe forwarded ports for the machine are listed below. Please note thatthese values may differ from values configured in the Vagrantfile if theprovider supports automatic port collision detection and resolution. 22 (guest) =&gt; 2222 (host)3.3 查看虚拟机状态3.3.1 查看当前vm状态$ cd ~/vm/ubuntu$ vagrant statusCurrent machine states: default poweroff (virtualbox) The VM is powered off. To restart the VM, simply run vagrant up 状态可能是：not create | 执行vagrant init命令后，从未启动过poweroff | 关机running | 运行中saved | 休眠 3.3.2 查看全部虚机状态此命令无需进入vagrant工作目录。$ vagrant global-status id name provider state directorybe5dee2 mfsmaster virtualbox poweroff /Users/pollyduan/vm/mfsa523de6 mfschunk1 virtualbox poweroff /Users/pollyduan/vm/mfs8377e0d mfschunk2 virtualbox poweroff /Users/pollyduan/vm/mfsb772b1f metalogger virtualbox poweroff /Users/pollyduan/vm/mfs8a5f10e mfsclient virtualbox poweroff /Users/pollyduan/vm/mfs63093ce default virtualbox poweroff /Users/pollyduan/vm/ubuntu 你可能会发现，为什么有的是default，有的是有名字的。这就是因为mfsxxxx是在vagrantfile中指定了vb.name，他对应的virtualbox工作目录也是这个值，而ubuntu这个虚机没有指定，所以是default，而且其virtualbox工作目录也是比较长的——ubuntu_default_1453944793418_7699。 global-status统计信息不是实时的，所有不能保证数据是绝对准确的。如果在vagrant up启动后，我们在virtualbox管理终端关闭vm，global-status是捕获不到的，它还是会显示running状态。截至1.8.1还是这样的，应该算是一个bug。处女座可能无法接受这个现实，那么你可以进入vagrant工作目录，手动再指定一次vagrant halt，状态就同步了。 4 其他命令4.1 help略。 4.2 login登录到中央仓库 4.3 plugin插件管理，略。 4.4 push发布镜像到中央仓库 4.5 version略。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用PHP将HTML页面生成PDF文档]]></title>
    <url>%2F%2Fmo-ren-fen-lei%2Fgenerate-pdf-documents-from-html-pages-using-php.html</url>
    <content type="text"><![CDATA[利用PHP将HTML页面生成PDF文档标签（空格分隔）： php特殊处理 使用TCPDF第三方类库进行生成githup下载地址：https://github.com/tecnickcom/tcpdf官方下载地址：http://sourceforge.net/projects/tcpdf/ 核心代码： 12345678910111213141516171819202122232425public static function writePdf($content) &#123; $pdf = new TCPDF(PDF_PAGE_ORIENTATION, PDF_UNIT, PDF_PAGE_FORMAT, true, 'UTF-8', false); $pdf-&gt;SetCreator(PDF_CREATOR); $pdf-&gt;SetHeaderData("logo.jpg", 70, 'wanglibao Agreement' . '', ''); $pdf-&gt;SetDefaultMonospacedFont(PDF_FONT_MONOSPACED); $pdf-&gt;SetMargins(PDF_MARGIN_LEFT, PDF_MARGIN_TOP, PDF_MARGIN_RIGHT); $pdf-&gt;SetHeaderMargin(PDF_MARGIN_HEADER); $pdf-&gt;SetFooterMargin(PDF_MARGIN_FOOTER); $pdf-&gt;SetAutoPageBreak(TRUE, PDF_MARGIN_BOTTOM); $pdf-&gt;setImageScale(PDF_IMAGE_SCALE_RATIO); $pdf-&gt;AddPage(); $pdf-&gt;setPageMark(); $pdf-&gt;SetFont('stsongstdlight', '', 13); $title = &lt;&lt;&lt;EOD&lt;h2&gt;标题&lt;/h2&gt;EOD; $pdf-&gt;writeHTML($content, true, false, false, false, '');// $pdf-&gt;writeHTML($content, true, 0, true, true);// $pdf-&gt;writeHTMLCell(0, 0, '', '', $content, 0, 1, 0, true, 'C', true); $pdf-&gt;lastPage(); $pdf-&gt;Output(date('Y-m-d') . '.pdf', 'I');&#125; 汉子出现乱码解决办法： 设置$pdf-&gt;setHeaderFont(array(PDF_FONT_NAME_MAIN,&#39;&#39;,PDF_FONT_SIZE_MAIN);其中PDF_FONT_NAME_MAIN就是设置头部的字体编码。将PDF_FONT_NAME_MAIN设置为 msungstdlight。页面中的字体：在 $pdf-&gt;writeHtml() ;或者$pdf-&gt;Cell();等之前设置 $pdf-&gt;SetFont(msungstdlight,&#39;&#39;, 字体大小)。 汉字不出现乱码的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php//引入tcpdf文件 require_once('./TCPDF-master/tcpdf.php'); //实例化 $pdf = new TCPDF('P', 'mm', 'A4', true, 'UTF-8', false); // 设置文档信息 $pdf-&gt;SetCreator('哈喽'); $pdf-&gt;SetAuthor('作者'); $pdf-&gt;SetTitle('哈哈哈哈哈哈'); $pdf-&gt;SetSubject('TCPDF Tutorial'); $pdf-&gt;SetKeywords('TCPDF, PDF, PHP'); // 设置页眉和页脚信息 $pdf-&gt;SetHeaderData('logo.png', 10, 'kkkkkk', '就是做个PDF', array(0,64,255), array(0,64,128)); $pdf-&gt;setFooterData(array(0,64,0), array(0,64,128)); // 设置页眉和页脚字体 $pdf-&gt;setHeaderFont(Array('stsongstdlight', '', '10')); $pdf-&gt;setFooterFont(Array('helvetica', '', '8')); // 设置默认等宽字体 $pdf-&gt;SetDefaultMonospacedFont('courier'); // 设置间距 $pdf-&gt;SetMargins(15, 27, 15); $pdf-&gt;SetHeaderMargin(5); $pdf-&gt;SetFooterMargin(10); // 设置分页 $pdf-&gt;SetAutoPageBreak(TRUE, 25); // set image scale factor $pdf-&gt;setImageScale(1.25); // set default font subsetting mode $pdf-&gt;setFontSubsetting(true); //设置字体 $pdf-&gt;SetFont('stsongstdlight', '', 14); $pdf-&gt;AddPage(); $str1 = " &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;哈哈&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;"; $pdf-&gt;WriteHTML($str1,'', 0, 'L', true, 0, false, false, 0); //输出PDF $pdf-&gt;Output('t.pdf', 'I');]]></content>
      <categories>
        <category>默认分类</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js实现mqtt 发布/发送 消息到主题]]></title>
    <url>%2F%2Ftechnology%2Fweb-nodemqtt.html</url>
    <content type="text"><![CDATA[node.js实现mqtt 发布/发送 消息到主题标签（空格分隔）： mqtt mqtt是啥?我的博客有写这个东西:传送门 安装首先你要安装node.js和npm 教程传送门 随后找个文件夹执行 命令行 安装mqtt模块; 1npm install mqtt 如果需要服务端 执行 1npm install mosca 使用 mqtt的文档 以下代码中有些参数可以从mqtt官方文档中得到解释 node.js中mqtt模块文档 mqtt协议入门文章 服务端123456789101112131415161718192021222324252627282930313233var mosca = require(&apos;mosca&apos;);//构建自带服务器var MqttServer = new mosca.Server(&#123; port: 1883&#125;);//对服务器端口进行配置， 在此端口进行监听MqttServer.on(&apos;clientConnected&apos;, function(client) &#123; //监听连接 console.log(&apos;client connected&apos;, client.id);&#125;);/** * 监听MQTT主题消息 **/MqttServer.on(&apos;published&apos;, function(packet, client) &#123; //当客户端有连接发布主题消息 var topic = packet.topic; console.log(packet); switch (topic) &#123; case &apos;test&apos;: console.log(&apos;message-publish&apos;, packet.payload.toString()); //MQTT转发主题消息 MqttServer.publish(&#123; topic: &apos;other&apos;, payload: &apos;sssss&apos; &#125;); break; case &apos;other&apos;: console.log(&apos;message-123&apos;, packet.payload.toString()); break; &#125;&#125;);MqttServer.on(&apos;ready&apos;, function() &#123; //当服务开启时 console.log(&apos;mqtt is running...&apos;);&#125;); PS: 不推荐node.js 作服务端 发布消息到主题123456789var mqtt = require(&apos;mqtt&apos;);var client = mqtt.connect(&apos;mqtt://127.0.0.1&apos;); //连接到服务端//client.subscribe(&apos;presence&apos;);var num = 0;var qtt = &#123;&#125;; //定义消息（可以为字符串、对象等）qtt = &apos;setr=xxxxxxx1xx&apos;;setInterval(function() &#123; //一秒钟发送一次 消息到主题 SN69143809293670state 消息为 setr=xxxxxxx1xx client.publish(&apos;SN69143809293670state&apos;, qtt, &#123; qos: 0, retain: true &#125;); &#125;, 1000); 订阅主题12345678var mqtt = require(&apos;mqtt&apos;); var client2 = mqtt.connect(&quot;mqtt://127.0.0.1:1883&quot;); //指定服务端地址和端口 client2.subscribe(&apos;test&apos;,&#123;qos:1&#125;);//订阅主题为test的消息 client2.on(&apos;message&apos;,function(top,message) &#123; console.log(message.toString()); &#125;); 制作接口(简化)我所接触的这个物理设备是发送给他一个 控制 或者 查询 请求到他订阅的主题中(ctr),并且它接收到控制信息,去执行.执行成功时 则会将 状态 发送到另一个 我订阅的主题中 .使用php实现比较麻烦,并且返回信息时有时无,使用node.js更方便,返回信息也更快; 物理环境 :centos7.2 64位,装有mqtt服务代理端mosquitto或其他mqtt协议代理. 安装可以自行搜索一下 和 node.js; 需要安装http 和 express 以及 mqtt 模块 npm install 模块名 node.js http模块文档 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182var mqtt = require(&apos;mqtt&apos;);var express = require(&quot;express&quot;);var app = express();var hostName = &apos;127.0.0.1&apos;; //http服务的提供服务ipvar port = 8080;var num = 1;person = new Object();person.firstname = &quot;Bill&quot;;app.all(&apos;*&apos;, function(req, res, next) &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;); res.header(&quot;X-Powered-By&quot;, &apos; 3.2.1&apos;) res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); next();&#125;);//json header头app.get(&quot;/zhinengjiaju/get&quot;, function(req, res) &#123; //如果有get请求/zhinengjiaju/get则执行回调中的代码(方便!) // console.log(&quot;请求url：&quot;, req.path) // console.log(&quot;请求参数：&quot;, req.query) req.setTimeout(200); //设置请求建立200ms 就中断接受请求,但还是在接收到返回信息后返回给它 var client = mqtt.connect(&apos;mqtt://127.0.0.1:1883&apos;, &#123; username: &apos;username&apos;, password: &apos;password&apos;, clientId: &apos;ap&apos; + num &#125;); //建立连接 client.on(&apos;connect&apos;, function() &#123; var sn = req.query.sn; var k = parseInt(req.query.k) - 1; // 127.0.0.1:8080/zhinengjiaju/get?sn=SN69143809293670&amp;k=1&amp;v=3&amp;cmd=setr client.subscribe(sn + &apos;state&apos;, &#123; qos: 1 &#125;); //开始订阅 if (req.query.cmd != &apos;setr&apos;) &#123; m = req.query.cmd; if (req.query.cmd == &apos;qk&apos;) &#123; m = &apos;setr=1111111111&apos;; &#125; if (req.query.cmd == &apos;qg&apos;) &#123; m = &apos;setr=0000000000&apos;; &#125; &#125; else &#123; var m = [&apos;x&apos;, &apos;x&apos;, &apos;x&apos;, &apos;x&apos;, &apos;x&apos;, &apos;x&apos;, &apos;x&apos;, &apos;x&apos;, &apos;x&apos;, &apos;x&apos;]; m[k] = req.query.v;; m = req.query.cmd + &apos;=&apos; + m.join(&apos;&apos;); &#125; //一系列简单接口处理 client.publish(sn + &apos;ctr&apos;, m, &#123; qos: 1, retain: true &#125;); // &apos;Hello mqtt &apos; + (num++) //发送 client.end(); //发送完后立即结束此次和服务端建立的请求 &#125;); client.on(&apos;message&apos;, function(topic, message) &#123; //订阅信息一直在运行,如果有设备返回信息到主题,就执行此回调 aaak(message.toString()); //将值通过aaak函数传递给res.end返回给页面数据; client.end(); &#125;); function aaak(aaaa) &#123; var objaaaa = JSON.parse(aaaa); // console.log(objaaaa); num++; client.end(); res.end(aaaa); &#125;&#125;)app.listen(port, hostName, function() &#123; console.log(`服务器运行在http://$&#123;hostName&#125;:$&#123;port&#125;`);&#125;); 谢谢支持,感觉不错打个赏;]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
      <tags>
        <tag>mqtt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker镜像下载\删除\查看命令_参数详解]]></title>
    <url>%2F%2Fnote%2Fdocker-image-download-delete-view-command-parameters-detailed.html</url>
    <content type="text"><![CDATA[Docker镜像下载\删除\查看命令_参数详解标签（空格分隔）： docker 镜像 下载\删除\查看: 镜像 下载: 1) . 下载最新系统 1docker pull centos 这里的centos是系统,如果后面不指定系统详细版本号会下载镜像源最新系统 * 2).*下载指定版本系统** 1docker pull centos:6.6 下载不同版本在centos后面加上冒号然后是版本号 后面使用的版本号依据搜索出来的镜像提供的一些版本编号来填写 3).Docker常用搜索镜像下载地址:Docker官网的镜像搜索阿里云提供的国内镜像下载 镜像 删除\查看: 1.停止所有的经过镜像实例化运行的容器，这样才能够删除其中的images： 查看容器: 12345678910111213141516docker ps 主要有些参数要说一下 1. 不加参数，表示查看当前正在运行的容器 2. -a，查看所有容器包括停止状态的容器 3. -l，查看最新创建的容器 4. -n=x，查看最后创建的x个容器 列一下docker ps的结果 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 这些分别代表什么 CONTAINER ID：容器ID，唯一标识容器 IMAGE：创建容器时所用的镜像 COMMAND：在容器最后运行的命令 CREATED：容器创建的时间 STATUS：容器的状态（你会看到UPXXX，表示运行状态） PORTS：对外开放的端口号 NAMES：容器名（也具有唯一性，docker是不允许创建容器名相同的容器的） stop [OPTIONS] CONTAINER [CONTAINER...]```1 options 名字 简写 默认 描述–time -t 10 秒杀之前等待停止 1232.查看当前有些什么images```docker images 3.删除images，通过image的id来指定删除谁 rmi [OPTIONS] IMAGE [IMAGE...]```123456``` options 名字 简写 描述--force -f 强制删除图像--no-prune 不要删除未标记的父母 例子: $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE test1 latest fd484f19954f 23 seconds ago 7 B (virtual 4.964 MB) test latest fd484f19954f 23 seconds ago 7 B (virtual 4.964 MB) test2 latest fd484f19954f 23 seconds ago 7 B (virtual 4.964 MB) $ docker rmi fd484f19954f Error: Conflict, cannot delete image fd484f19954f because it is tagged in multiple repositories, use -f to force 2013/12/11 05:47:16 Error: failed to remove one or more images $ docker rmi test1 Untagged: test1:latest $ docker rmi test2 Untagged: test2:latest $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE test latest fd484f19954f 23 seconds ago 7 B (virtual 4.964 MB) $ docker rmi test Untagged: test:latest Deleted: fd484f19954f4920da7ff372b5067f5b7ddb2fd3830cecd17b96ea9e286ba5b8 #### 问题回顾 删除时出现 12$ docker rmi 196e0ce0c9fbError response from daemon: conflict: unable to delete 196e0ce0c9fb (must be forced) - image is referenced in multiple repositories 可以尝试 docker rmi daocloud.io/centos #REPOSITORY 栏中的文字 再次删除时出现 Untagged: daocloud.io/centos:latest 尝试删除 docker rmi #IMAGE ID 栏中的文字 问题示例： 123456789101112131415161718192021222324252627282930313233Administrator@DESKTOP-679OPI8 MINGW64 ~$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESAdministrator@DESKTOP-679OPI8 MINGW64 ~$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdaocloud.io/centos 7 196e0ce0c9fb 5 months ago 197MBdaocloud.io/centos latest 196e0ce0c9fb 5 months ago 197MBAdministrator@DESKTOP-679OPI8 MINGW64 ~$ docker rmi 196e0ce0c9fbError response from daemon: conflict: unable to delete 196e0ce0c9fb (must be forced) - image is referenced in multiple repositoriesAdministrator@DESKTOP-679OPI8 MINGW64 ~$ docker rmi daocloud.io/centosUntagged: daocloud.io/centos:latestAdministrator@DESKTOP-679OPI8 MINGW64 ~$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdaocloud.io/centos 7 196e0ce0c9fb 5 months ago 197MBAdministrator@DESKTOP-679OPI8 MINGW64 ~$ docker rmi daocloud.io/centosError: No such image: daocloud.io/centosAdministrator@DESKTOP-679OPI8 MINGW64 ~$ docker rmi 196e0ce0c9fbUntagged: daocloud.io/centos:7Untagged: daocloud.io/centos@sha256:822de5245dc5b659df56dd32795b08ae42db4cc901f3462fc509e91e97132dc0Deleted: sha256:196e0ce0c9fbb31da595b893dd39bc9fd4aa78a474bbdc21459a3ebe855b7768Deleted: sha256:cf516324493c00941ac20020801553e87ed24c564fb3f269409ad138945948d4]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker配置开发环境常用命令_参数详解(1]]></title>
    <url>%2F%2Fnote%2Fdocker-configuration-development-environment-commonly-used-commands-parameters-detailed-1.html</url>
    <content type="text"><![CDATA[Docker配置开发环境常用命令_参数详解标签（空格分隔）： docker 在下载image后我们需要一个可以运行项目的环境 使用下载的image运行容器命令：docker run 123456789当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：检查本地是否存在指定的镜像，不存在就从公有仓库下载利用镜像创建并启动一个容器分配一个文件系统，并在只读的镜像层外面挂载一层可读写层从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去从地址池配置一个 ip 地址给容器执行用户指定的应用程序执行完毕后容器被终止 用法 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] Options 名字，速记默认描述--add-host添加一个自定义的主机IP映射（主持人：IP）--attach , -aattach到stdin stdout或stderr，--blkio-weight块IO（相对量），10和1000之间，或0禁用（默认为0）--blkio-weight-device块IO量（相对装置重量）--cap-add添加Linux的功能--cap-dropLinux的能力下降--cgroup-parent可选的父容器的C--cidfile写容器的ID文件--cpu-countCPU数量（Windows）--cpu-percentCPU的百分比（Windows）--cpu-period限制CPU CFS（完全公平调度器）期--cpu-quota限制CPU CFS（完全公平调度器）定额--cpu-rt-periodAPI 1.25限制CPU的实时周期在微秒--cpu-rt-runtimeAPI 1.25限制CPU的实时运行在微秒--cpu-shares , -cCPU份额（相对量）--cpusAPI 1.25CPU数量--cpuset-cpus这允许CPU执行（0，0）--cpuset-memsMEMS中允许执行（0，0）--detach , -d运行容器的背景和打印容器ID--detach-keys分离容器覆盖关键序列--device添加一个主机装置的容器--device-cgroup-rule添加一条规则，允许设备列表的C--device-read-bps限制读取速度（每秒字节数）从设备--device-read-iops限制读取率（IO每秒）从设备--device-write-bps限制写速率（每秒字节数）的一种装置--device-write-iops限制写速率（IO每秒）的一种装置--disable-content-trusttrue跳过图像验证--dns设置自定义的DNS服务器--dns-opt设置DNS选项--dns-option设置DNS选项--dns-search设置自定义DNS搜索域--entrypoint覆盖图像的默认入口点--env , -e设置环境变量--env-file在一个环境变量文件读取--expose揭露一个端口或端口范围--group-add添加额外的团体加入--health-cmd要运行的命令来检查卫生--health-interval之间运行的检查时间（MS |的| M | H）（默认0s）--health-retries连续的失败需要报告不良--health-start-periodAPI 1.29对于容器初始化之前开始倒计时起始期健康重试（MS |的| M | H）（默认0s）--health-timeout允许一个检查运行的最大时间（MS |的| M | H）（默认0s）--help打印使用--hostname , -h容器的主机名称--initAPI 1.25运行容器内转发信号和收获过程中的一个初始化--interactive , -i保持输入打开即使不连接--io-maxbandwidth的驱动系统的最大IO带宽限制（仅适用于Windows）--io-maxiops对系统驱动Maximum IOps极限（Windows）--ipIPv4地址（例如，172.30.100.104）--ip6IPv6的地址（例如，2001：db8：：33）--ipcIPC模式使用--isolation容器隔离技术--kernel-memory内核内存限制--label , -l设置元数据容器--label-file读一行分隔的文件标签--link添加链接到另一个容器--link-local-ip集装箱IPv4和IPv6链路本地地址--log-driver测井的集装箱司机--log-opt日志驱动器选项--mac-address集装箱的MAC地址（例如92：D0：c6:0a：29:33）--memory , -m内存限制--memory-reservation记忆软限制--memory-swap互换限额等于内存和交换：&amp;#39; 1 &amp;#39;使无限的互换--memory-swappiness-1调容器内存swappiness（0到100）--mount将文件系统挂载到容器--name在容器分配一个名字--net连接到网络的一个容器--net-alias添加网络域别名容器--network连接到网络的一个容器--network-alias添加网络域别名容器--no-healthcheck禁用任何容器指定的检查--oom-kill-disable禁用OOM Killer--oom-score-adj调主机的OOM的偏好（1000到1000）--pidPID命名空间的使用--pids-limit调整PID（集1容器极限无限）--platform实验（守护）API 1.32如果服务器是多平台可设置平台--privileged给这个容器扩展权限--publish , -pPublish a container’s port(s) to the host--publish-all , -P发布所有暴露的端口随机端口--read-only装入容器的根文件系统为只读--restartno重启政策适用在集装箱出口--rm自动删除容器时退出--runtime运行时使用此容器--security-opt安全选项--shm-size大小/ dev / shm--sig-proxytrue代理接收到的信号的过程--stop-signalSIGTERM信号停止一个容器--stop-timeoutAPI 1.25超时（秒）停止一个容器--storage-opt对于集装箱存储驱动程序选项--sysctlsysctl选项--tmpfs安装tmpfs目录--tty , -t分配给伪tty--ulimitulimit选项--user , -uUsername or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])--userns用户要使用的名称空间--utsUTS命名空间的使用--volume , -v绑定安装卷--volume-driver容器的体积驱动可选--volumes-from山卷从指定的容器（S）--workdir , -w容器内的工作目录 1234------------##### 非主流用法：###### 使用image创建container并执行相应命令，然后停止 $ docker run centos echo ‘123’Unable to find image ‘centos:latest’ locallylatest: Pulling from library/centosaf4b0a2388c6: Pull completeDigest: sha256:2671f7a3eea36ce43609e9fe7435ade83094291055f1c96d9d1d1d7c0b986a5dStatus: Downloaded newer image for centos:latestps:以上是下载最新的centos过程123 1234567891011 这是最简单的方式，跟在本地直接执行echo &apos;hello world&apos; 几乎感觉不出任何区别，而实际上它会从本地 **centos:latest** 镜像启动到一个容器并执行打印命令后退出（docker ps -l可查看）。 需要注意的是，默认有一个 **--rm=true** 参数，即完成操作后停止容器并从文件系统移除。因为Docker的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。容器启动后会自动随机生成一个CONTAINER ID，这个ID在后面commit命令后可以变为IMAGE ID##### 主流用法：###### 使用image创建container并进入交互模式, login shell是/bin/bash`docker run -i --name cee -t centos:7.2.1511 /bin/bash`使用示例： 12docker run -i --name cee -t centos:7.2.1511 /bin/bash[root@90df89d56b3e /]# 使用到的option： |参数|含义||—|—|—||-i |保持输入打开即使不连接（类似于后台运行）||–name |标记可以为容器自定义命名||-t |docker可以虚拟出一个TTY窗口|]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker配置开发环境常用命令_参数详解(3]]></title>
    <url>%2F%2Fnote%2Fdocker-configuration-development-environment-commonly-used-commands-parameters-detailed-3.html</url>
    <content type="text"><![CDATA[文章不兼容, 已放到时光机]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer组件开发]]></title>
    <url>%2F%2Ftechnology-php%2Fcomposer-component-development.html</url>
    <content type="text"><![CDATA[composer组件开发标签（空格分隔）： composer组件开发 http://www.chenjie.info/1880 入门https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE git tag 标签使用https://packagist.org/about#how-to-update-packages 官方教程(包括自动更新)]]></content>
      <categories>
        <category>PHP技术栈</category>
      </categories>
      <tags>
        <tag>composer</tag>
      </tags>
  </entry>
</search>
