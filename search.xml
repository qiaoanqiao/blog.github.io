<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[最近看的一系列自我分析和职业认知系列文章]]></title>
    <url>%2F%2Fdefault%2Fa-series-of-selfanalysis-and-professional-cognition-recently-read.html</url>
    <content type="text"><![CDATA[右侧有滚动 分为6部分. 我是抓包抓过来的文章内容. 如果实在有继续阅读学习兴趣的可以添加微信号 tyy11556633 说明是从我的博客看到的 一个模型，帮你找到真正热爱的工作 1 本节学习收获：掌握冰山模型的用法，能够用它来分析自己跟工作的匹配度，从而做出正确的职业选择，并能精准找到自己喜欢并有成就感的工作。 &nbsp; “我感觉目前的工作状态不是我最想要的，做得也还行，但没有太多成就感，也不知道未来发展会怎么样......想有一份真正热爱并且有前途的工作，但不知道应该做什么，感觉很迷茫“。 &nbsp; 这段话，要么是我们当下的状态，要么是曾经有过的状态。 &nbsp; 刚工作发现不喜欢想转行，到了新岗位发现不胜任想提升，人到中年发现这个工作的天花板等等，都是常态。因为我们对自己的事业有期许，但当下的工作可能无法承载这样的期许，所以会觉得“不喜欢”，“很迷茫”。 &nbsp; 可是，“不喜欢”，“很迷茫”只是一种情绪，情绪背后的原因是什么呢？我们喜欢，又有前途的工作到底在哪里呢？这节课，我给你介绍一个模型，然后用它来帮你做好职业选择和定位，让你不再迷茫。 &nbsp; 这个模型称为冰山模型，你可能听过，但我还是会简单介绍一下，然后告诉你这个模型有哪些妙用，用好它，差不多可以解决你一半以上的学习和发展问题。 &nbsp; 冰山模型是美国著名心理学家麦克利兰提出来的，它全面地描述了一个人的个体素质要素，也就是说，你跟一个岗位是不是匹配，匹配程度如何，市场薪资值多少，都是这个模型可以解释的，几乎所有大公司都会用它来进行人才招聘和培养。 &nbsp; 第一部分，知识和技能 &nbsp; 冰山模型从上到下有很多要素，最上面的要素是知识和技能。 &nbsp; 知识，就是我们在学习和实践中获得的认知和经验，比如财务知识，人力资源知识等等，包括我们现在学习的冰山模型，也属于知识。这跟你大学所学的专业，常看的书，从事的工作，甚至业余爱好都有关系。 &nbsp; 技能是指你所具备的某项专门技术，比如骑自行车，编程，使用的Excel等等。 &nbsp; 一个人的知识和技能是可以后天习得的，也是非常显性，容易看出来的。所以，我们称为冰山上的部分。 &nbsp; 知识技能跟工作之间的关系是什么呢？简单来说，如果你的工作中有很多陌生的内容，觉得每天都信息量很大，来不及接收，感到慌乱和焦虑，很可能就是你的知识技能跟岗位不匹配。但这不是什么大问题，因为知识和技能比较容易补齐，上上课，看看书，跟资深同事学，一段时间之后就能提升。 &nbsp; 第二部分，能力 &nbsp; 冰山模型中间的要素是能力，或叫通用能力，比如学习和思考能力，人际交往能力等。相对知识和技能来说，能力高低不是一眼就能看出来的。比如，一个人的创新能力到底如何，很难用一个证书，几道题目来考察，而需要看他在处理很多问题时候的行为。 &nbsp; 能力跟知识技能最大的区别在于：。知识和技能属于特定领域，而则能力更多的英文通用领域的比如，知识会分财务，人力资源，金融等等，但是“创新”这样的能力，是适用于任何领域的，一旦掌握，是能够迁移的。 &nbsp; 那么，如果能力不匹配，在工作中会如何呢？工作效率，沟通效率较低，面对复杂的问题无从下手，缺乏成就感，力不从心。能力的培养周期相对长一些，一般要几个月时间，我们后面几节会讲方法。 &nbsp; 第三部分，价值观，性格，动机 &nbsp; 冰山模型最底下包括价值观，性格特质，动机这些要素在成年之后很难被改变。，它们会受基因，家庭教育，童年经历等等的影响简单介绍一下各个要素： &nbsp; 价值观是你判断事物的标准，比如说，当你在择业的时候，自由和稳定产生了冲突，你选择哪个，放弃哪个;在事业和家庭产生冲突的时候，你怎么处理，等等如果你在工作中经常陷入矛盾和纠结，对所做的事情很难发自内心地认同，很可能就是价值观上不匹配，比如你做自媒体，公司为了赚钱让你写一些低俗内容，但你觉得那对用户没有价值。&nbsp; &nbsp; 性格特质则是个人的行为偏好，比如，你是偏内向还是外向，更关注宏观还是细节，等等。如果你在工作中发现，自己好像工作量没有很大，但却觉得心累，很有可能是性格不匹配。比如，你是内向性格的人，是从独处中获得能量，但你做了一份每天都要不断跟陌生人沟通的工作。&nbsp; &nbsp; 至于动机，其实动机的分类方法有很多，最常见的是麦克利兰的理论，分为成就动机，权力动机和亲和动机成就动机的人，喜欢挑战;权力动机的人，希望影响他人;而亲和动机的人，希望维持更好的团队关系。如果你感觉自己没有动力，做事提不起劲儿来，那很可能就是现在的工作跟你的动机不匹配，比如你明明是成就感动机，喜欢一定挑战，但你的工作却高度重复。 &nbsp; 好了，我们讲完整个冰山模型，现在你知道了，工作跟伴侣是一样的，“匹配”比“优秀”重要，而你跟一份工作的匹配要素，其实就是冰山模型中的要素。所以，我们感觉一份工作不喜欢，有可能是缺乏知识技能导致的慌乱和焦虑，缺乏能力导致的挫败和低效，价值观不匹配导致的矛盾和纠结，动机不匹配导致的没热情，或者性格特质不匹配导致的心累。 而且，所有匹配要素里面，冰山底层的隐性要素起到了更大的作用，就像找伴侣一样，尽管看起来表面条件差不多，但你就是对一个人有感觉而对另一个人没有，这就是冰山底层的隐性要素在发挥作用。 &nbsp; 所以，知道了这个模型，你就可以分析了，如果目前的工作自己不是很喜欢，那么到底是哪里不喜欢。 &nbsp; 好了，现在我们分析的是现有岗位是否喜欢，那么假如我现在是销售，发现并不喜欢，想要转行做互联网运营，面对这样一个陌生岗位，不知道自己是否匹配，这时候应该怎么办呢？或者说，我不喜欢销售工作，但我面对运营，产品经理，市场分析等等这些可能感兴趣的岗位，不知道该去哪一个，又该怎么办呢？这世界上有几千种岗位，我们总不能全都干一遍然后再选。 &nbsp; 其实很简单，你把目标岗位用冰山模型分析一下，就可以了。 &nbsp; ？具体该怎么做呢分成四步： &nbsp; 第一步，先确定一个你要分析的岗位。 &nbsp; 比如你有一个目标岗位，那么很简单，就用这个岗位来分析自己是不是匹配。但如果你没有，可以先从自己的相关经验出发，框定你能做的几个岗位，一个个分析。这里教你一个技巧，比如你在某个行业做技术服务，但目前的工作不喜欢，想要换，可又不知道自己能换什么，这时候可以去领英等等这类招聘平台去搜索，就搜这个文教的技术服务岗位，然后会出来一堆人，你看这些人的履历，看看他们后来都去了哪里，你就知道潜在的方向了。而且，这个方法也能帮你判断，未来你要去的这个行业和岗位，到底有没有前途，这些原先做该岗位的人，后面的出路是什么。 &nbsp; 第二步，在招聘网站上，搜索这个岗位的招聘要求。 &nbsp; 这时候，你会搜到很多公司对这个岗位的招聘要求，找出几份不同的招聘需求。因为不同公司会有自己的细分要求，为了提取出共性要求，你可以尽可能多看几份，找到共性。 &nbsp; 第三步，按照冰山模型，综合分析这些招聘需求。 &nbsp; 你会发现，招聘需求基本上也是按照冰山模型来写的，以新媒体运营岗位来说，有对知识的要求，比如传播学或文学专业毕业，了解内容营销的知识，熟悉新媒体平台;有对技能的要求，比如精通公众号排版工具使用;也有对能力的要求，比如文案写作能力，用户思维，学习能力等等;最后，还有对性格特质，动机等等的要求，比如细心，热爱挑战等等。把它们汇总在一起，就可以得到这份岗位的需求模型了。 &nbsp; 第四步，按照岗位需求模型，与自己进行对比。 &nbsp; 岗位需求模型已经出来了，那么自己就可以对照一下，自己到底是不是符合，是否应该换工作或转行。当然，我们很难找到完全匹配的工作，如果是冰山底层的因素不匹配，那么不太建议选择这个职业，因为这些要素后天很难改变;但如果是知识，技能方面不匹配，未必不能选，因为大部分知识和技能都是可以后天学习的，只是看你是否愿意投入时间罢了。 &nbsp; 我们平时看一份工作，大都是看冰山表层，比如职责，薪资，办公环境，学历，专业等等因素，可最终你这份工作能不能做好，是否有成就感，其实是很多隐性要素所决定的，今天的内容，其实是把你对工作的感觉给表述出来了，被分解成了你的性格特质，动机，价值观，也就避免了我们一个个去尝试然后看喜不喜欢。 &nbsp; 我一直认为，搞明白“我应该选择什么样的工作”，比“我应该如何在别人认为的好工作里面成功”，要重要得多。毕竟，想要让自己获得成就感和满足感，就不应该把它绑在别人的记分牌上。 &nbsp; 好了，今天我们讲了冰山模型，你会发现，它不只是能用在职业选择方面，还可以用在其他很多方面，比如今天稍微提到一点的伴侣选择，还有子女教育，很多父母都给孩子报很多培训班，但孩子时间有限，所以应该选什么培训班呢？是教孩子背背单词和儿歌，还是开发思维的课程呢？如果你知道了冰山模型，相信会有答案。 &nbsp; 所以，我想告诉你的是，我们所学习的每个方法论和模型，都不是只能解决一个问题，而是可以解决几百甚至几千个问题，查理芒格在“穷查理宝典”里面提到，掌握一定数量的思维模型，能解决这世上90％的问题。你会发现，同样的知识量，如果你能用知识解决更多问题，那你的学习投入产出比就是最高的。 &nbsp; 这是我的学习理念，也是圈外的教育理念。我希望在这6天的课程里，你不只是知道了一些知识点，而是培养了一种思维方式，如果是这样，这个短短6天的课程，也就达到我的目的了。 &nbsp; 好了，正如我们刚才说的，冰山模型有很多作用，除了帮你匹配工作，其实它还可以用来衡量你的市场价值，也就是薪资。公司会通过简历，面试来考察候选人在冰山模型各个要素的表现情况，来确定对方的薪资。 &nbsp; 下节课，我会告诉你：如何借助冰山模型，你让市场的快速价值提升以及，为什么有些岗位门槛很高，但天花板却很低，而另一些岗位看起来很好入行，做到顶尖却很难？我们明天见！ 四大要素，决定了你的市场价值 2本节学习收获：明确冰山模型各个要素的投入产出比，从而更好地分配自己的时间，让自己变得更值钱；同时，理解不同类型的岗位所对应的门槛和天花板，帮助择业&nbsp; 我们都会发现，同样学校、同样专业的两个人，在毕业几年之后，薪资差异可能非常大。大家起点差不多、毕业时间差不多、每天投入的工作时间也差不多，但最后产出却不一样，到底是什么原因呢？我们自己的时间应该要投入在哪里，才能最大化我们的市场价值也就是薪资呢？今天我们用科学的方法做个分析。&nbsp;首先，薪资，也就是一个人的市场价值，无非是跟内部和外部两类因素相关。外部就是机遇、运气、选择等等；而内部，其实就是我们在冰山模型各个要素上的表现，我们的知识技能越多、能力越强、价值观/性格特质/动机跟所做的事情越匹配，你的市场价值就越高。&nbsp;所以，抛开运气、选择这些很难掌控的因素不谈，我们今天从内部角度，也就是冰山模型的各个要素，来聊聊市场价值怎么提升。&nbsp;说具体方法之前，我们先得有一个认识，那就是整个冰山模型越往下的要素，越难培养、越难发现，比如学一个知识，冰山模型，我跟你讲一下马上就知道，但是提升一种能力，比如解决问题的能力，那不是听讲就行的。可是呢，也因为越往下的要素越难，相对也越能成为竞争优势。同时，你应该也发现了，这几个要素并不是独立的，冰山下面的要素会影响上面的要素。举例来说，一个人的知识储备有多少，跟ta的学习能力、动机等等都非常相关。如果你的学习和思考能力更强、并以追求真理作为价值观，知识储备就会更高。根据研究，冰山底层的要素中，光个性特质就能够解释员工绩效差异的35%，而冰山底层的因素加起来，差不多决定了一个人的70%。好了，有了这个认知，我们接下来挨个分析，把时间投入在不同的要素上，会有什么结果。首先是投入到知识。&nbsp;我们可能觉得知识很值钱，毕竟“知识付费”嘛。但说实话，单纯用知识很难赚钱。&nbsp;为什么呢？&nbsp;其一，当今社会，你想知道什么，网上搜索就可以了，可替代性太高。比如说，你就算把百科全书背下来，最后可能还得靠卖记忆力课程赚钱，而没法通过这个知识直接赚钱。&nbsp;其二，知识跟思维，是有差别的。有句古语叫“学富五车”，出自《庄子·天下》，形容一个人知识渊博，但那时候不是纸质书、是用竹简的，而且车也是马车，不是火车，所以五车竹简能装多少知识呢？最多十几二十万字，也就一本书。所以，现代社会，随便一个人，知识储备都超过孔子、老子、亚里士多德。但你为什么还在学他们呢？因为知识跟思维是不一样的，你学的是他们的思维。而思维是一种能力，用知识解释以及解决问题的能力。所以，你会发现，单纯的知识储备，如果不能结合思维能力去解决一些具体问题，是很难提升你的市场价值的。&nbsp;第二种选择是投入到技能。&nbsp;有一些职业是有专业门槛的，比如程序员、设计师，这属于技能型岗位，因为这些岗位有一个进入门槛，往往会让人觉得非常有安全感。反过来，像是做销售、市场、运营类工作的人，或者大学学习经管这种万金油专业的同学，常常会觉得“哎呀，我没有一技之长，好没安全感”。但实际上，门槛高，不代表天花板也高，毕竟没人想要一直拿每个工作的门槛工资，我们是往上看的。&nbsp;技能的定价如何？天花板在哪里呢？取决于该技能的稀缺性。&nbsp;10多年前，很多大企业都会给有CPA证书的人支付一个叫做Market Premium（市场溢价）的额外工资，因为这个技能当时相对稀缺，所以公司需要支付溢价才能招到人。可是，这个技能的市场价格高，就会有很多人进入到这个领域，人才供需逐渐稳定，那么溢价就消失了。程序员岗位也一样，在移动互联网红利期的时候，行业增长快，所以对程序员的需求非常旺盛，而市场供给还没来得及跟上，所以带来了程序员的高工资。但是，这两年红利消失，增长放缓，对程序员的需求就会下降，可供给没有下降，所以会导致工资水平上不去，但因为不能降薪，所以很多公司规定的工作时间越来越长，以此来变相降薪，“996事件”的爆发跟这个趋势有很大关系。&nbsp;当然，那些有管理技能、商业思维、能解决复杂问题的程序员，薪资依然很高，但他们已经不单单是靠技能吃饭了，而是具备了很高的能力。&nbsp;一个很有意思的现象，在圈外的付费学员中，工作5年以下的人群技术人员占比不高，但是5年以上的人群中，就有特别多技术人员。因为他们发现技能带来的薪资提升是有天花板的，所以需要提升管理能力、解决问题的能力，来获得更高的职业回报、突破发展瓶颈。&nbsp;所以，技能在稀缺的时期很值钱，一旦行业变动、人才供给增多，市场价值就会下跌，不得不学习新的技能。&nbsp;第三种选择是投入到能力。&nbsp;有一些岗位，对技能没有特殊要求，看起来好像门槛不高，但薪资天花板却很高，而且薪资范围很宽，例如互联网运营、产品经理、项目经理、还有大多数的管理岗位。厉害的产品经理像上亿年薪的张小龙，而一般的产品经理可能月薪才一万，他们的薪资差异并不在于技能的不同，比如谁画的产品原型图更好，而是能力高低。所以，这些岗位也被称为是能力导向型岗位。&nbsp;圈外商学院有一位深圳的学员，在一家传统行业的500强企业做工程师，带公司内部的一些技术项目。工作5年，薪资一万多，他觉得支撑不了家庭未来的需要，想要晋升，但他发现，公司的部门经理都在35-45岁之间，而自己才27岁，还需要熬很多年，于是纠结要不要投身互联网。但他也担心跨行会不会成功，以及不知道如何着手。后来他在圈外学了近半年，知道了不同行业所需要的很多能力是相通的，所以坚定了信心，而且找到圈外的朋友了解目标岗位的情况，最后在一家互联网大厂拿到了项目管理的offer，薪资翻了倍。他后来跟大家分享的时候提到，面试中问了很多如何带团队、带项目的问题，都是课程里面学过的。当然，想要了解他的故事，可以跟班主任要文章链接，他太太有在圈外公众号写过一篇文章，提到过这段经历。&nbsp;所以，能力提升是可以跨行业跨职业的，一旦积累到一定高度，哪怕行业不行，换个地方一样可以值钱。&nbsp;第四种选择是投入到冰山模型底层的自我发现。&nbsp;冰山底部的性格特质、动机、价值观这些要素，虽然难以改变和发现，但是，如果我们对自己能有一个清晰的认识，然后找到跟这些要素相匹配的工作，其实也能大大提升我们的市场价值。&nbsp;比如说，我是一个高成就动机的人，在亲和动机方面比较弱，从这个角度看，咨询公司就非常适合我，因为工作挑战大、容易有成就感。但如果我去某个注重关系和家庭氛围的国有企业，那我就会感到不适，最终很难得到提升。环境其实是一种外部驱动力，你选到了适合的地方，自然成长效率就会更高。所谓“橘生淮南则为橘，生于淮北则为枳”。&nbsp;好了，从上面的四种选择我们可以看到，从长期来说，想要提升自己的市场价值，把大多数时间花在提升能力和认识自己冰山底层要素上面，是最好的选择。但事实上，大多数人是怎么做的呢？每天打开各种学习产品、不断学很多碎片化知识，练习一些并不稀缺的技能、考各种几个月就能拿下来的证，最后收入还是上不去，反而会觉得很挫败。&nbsp;为什么我们大多数人会做出这样的选择呢？&nbsp;第一，知识和技能的学习最容易。它们的获得门槛很低，听一堂课、学一个知识，这是几乎所有人都能做到的事情。而能力就不一样了，需要持续投入、刻意练习。人们总是倾向于做容易的事情，而不是正确的事情。&nbsp;第二，受限于目前岗位的定位。前面有提到，其实一些岗位的性质，本身就是技能导向型的，对你没什么能力要求，只需要表格做得越快越好、流程越熟练越好。而人都是有惰性的，在这种岗位要求下，也就没有动力去提升眼前岗位不需要、但长远更有价值的能力了。所以有时候我会说：你选的不是一份工作，而是一个天花板。&nbsp;第三，没有看清楚工作的本质。很多人以为值钱的是知识和经验，但并非如此。本质来说，任何工作都是在解决问题，营销解决的是如何让用户知道我们的产品、HR解决的是如何让公司有充足的人才供给等等，往大了说，不仅我们的工作，一家公司也是在解决某类用户问题，滴滴解决打不到车的问题，饿了么解决不想出门吃饭的问题，等等。&nbsp;既然本质是解决问题，所以你单有一个知识就是没用的。你会背很多营销理论，但没法帮公司宣传和卖出更多产品，就是没价值的。&nbsp;好了，我们现在知道了，要花时间去认识自己和提升能力。&nbsp;关于认识自己，圈外商学院里有这个课程，但自我认知是一个持续的、慢慢发现的过程，课程也只是供参考，我们这次先不展开。&nbsp;关于提升能力，这是任何职业阶段的人都应该去做的，而且你投入了就一定会有回报。&nbsp;但你有没有发现，同样两个人，都培养自己的某项能力，比如结构化思维，一个人很快就能提升，但另一个人好像努力了很久也没有太大效果？这跟我们每个人的天赋有关，我下一节课告诉你，关于天赋的一些研究成果，以及大多数人对天赋的误解，并且会帮你找出自己的天赋，让你能够更快速地提升能力，进入发展快车道。&nbsp;好，今天这节课，我们知道了：&nbsp;知识容易获取跟习得，如果不能用它解决问题，几乎就没什么竞争力；&nbsp;技能有进入门槛，其市场价值取决于稀缺程度，但长期来说，所有技能都会走向供需平衡，高收入不可持续；&nbsp;能力可迁移，并且对知识和技能也有很大促进，值得我们多投入；&nbsp;而每个人的性格、动机和价值观不同，所以做不同的工作，也会有产出的不同。&nbsp;总之来说，我们的时间应该多投入在后两者上面，但现实是大多数人都在提升前两者。我们的时间，永远应该花在正确的事情上，而不是容易的事情上。 四类迹象，发现你的隐藏能力 3本节学习收获：掌握SIGN模型，从而找到自己的天赋，并借此进入发展快车道&nbsp; 我还在咨询公司的时候，带过两个相似起点、但结局完全不同的顾问。&nbsp;A顾问大学是学行政管理的，实习期间执行力很强，自己做实习生团队的小头目，但有个很大的问题，她总是点状思考，没有框架。虽然后来我还是争取破格留下了她，但是，我一直担心她未来上升会有瓶颈。&nbsp;入职不到一年的时候，我有次让她写份报告，做好了大量修改的心理准备，但我惊讶地发现，结构竟然非常清晰，丝毫不比其他人差。&nbsp;后来我问她：你为什么一下子进步了呢？她说：我不知道，好像某天突然顿悟了。&nbsp;另一个是T顾问，她之前在甲方工作过很短时间。转行过来以后，她的表现跟A顾问很像，执行力不错，但常常找不到思路。&nbsp;本来以为她也能像A顾问一样成长起来，所以我经常带她讨论，一起复盘。&nbsp;经过一段时间，她的思维能力有所进步，但是，涉及到新问题，还是不得要领。之后一年，T顾问每天加班到深夜，觉得很难撑下去，就离开咨询公司回到了甲方。&nbsp;当时我一直不明白，两个人的差异在哪里。后来，随着我管理经验增多，加之对人才发展领域更加了解，才找到了答案。结合我们这一节课的主题，相信你也猜到了，答案跟天赋有关。&nbsp;优势心理学之父唐纳德·克里夫顿博士，曾经带领团队进行了一项长达50年、基于200万人的研究。研究表明，虽然成功的道路有千万条，但成功人士基本上都遵循了一个原则，就是将自身天赋发挥到了极致。&nbsp;更重要的是，他指出：天赋并不是少数人的专属，每个人都有自己的天赋。&nbsp;这里的天赋是什么呢？天赋就是隐藏的能力，让一个人可以在同样起点的情况下，更加快速地成长。&nbsp;也就是说，在某个领域内天赋高的人与该领域里的一般人，他们的努力与水平之间的关系，类似于图片里的两条实线。&nbsp;&nbsp;但是我们大多数人，往往以为天赋=能力，以为天赋是那条虚线，以为只要有天赋，不需要努力就可以达成结果。实际上，天赋只是个催化剂，是加快反应的。可以说，天赋是一种隐藏能力，是否能够转化为显性的能力，则是需要后天刻意练习的。&nbsp;这也就解释了开头那个故事，为什么A顾问可以进步得这么迅速，因为系统化思维并非她天生的弱势，只是她之前专业和实习里面，没有让她刻意练习的机会，所以展现不出来。&nbsp;而T顾问呢？天赋上欠缺系统化思维，后天的练习确实可以起到作用，但没有A顾问那么快进步，时间一长，对比身边人，很容易沮丧挫败，从而没有动力去提升。&nbsp;当然，A顾问的事业就一定会比T顾问更成功吗？不是，因为世界上不是只有这一份工作。事实上，T顾问回到甲方后，工作做得很不错。&nbsp;所以，找到你的天赋，并且培养它，发挥它，就能够让你事半功倍地获得提升，而且，你做事会更有成就感。&nbsp;好了，你肯定很想知道：我的天赋是什么呢？我有什么隐藏能力呢？&nbsp;接下来我给你一个探索方法，让你更快发现自己的天赋。&nbsp;天赋有四个表现，简称为“SIGN”，可以帮你在日常生活和工作中发现它：&nbsp;表现一：自我效能（Self-efficacy）&nbsp;字母S对应的表现是Self-efficacy，自我效能。它的意思是对于某些任务，你的信心很强，觉得自己肯定能做好。&nbsp;比如，每当面对细节琐碎的事情时，还没开始，我就觉得自己做不好，但每当要我去解决一个难题时，我会充满信心。&nbsp;所以，当你对某类事非常有信心，觉得自己可以做成功，这就是天赋的其中一个表现。&nbsp;表现二：本能（Instinct）&nbsp;字母I对应的表现是Instinct，本能。意思是当你还没有开始做这件事的时候，你就迫不及待地想要尝试了。&nbsp;比如，当我决定要开发课程、教给别人的时候，我会感到异常兴奋，会思考很多方法，会想如何让学员更愿意以及更容易掌握这些内容。所以，那些让你迫不及待、跃跃欲试的事情，可能意味着你天赋的所在。&nbsp;表现三：成长（Growth）&nbsp;字母G对应的表现是Growth，成长。正如前面提到的天赋曲线那样，你发现自己学得很快，相同的时间投入，会带来更多的成长。比如，当我为了搞清楚某个商业模式，去阅读大量相关资料的时候，一上午对我来说，就跟20分钟一样。&nbsp;如果在某个领域，你一接触就明显比别人进步得要快一些，这也是天赋给你的一个信号。&nbsp;表现四：满足（Needs）&nbsp;字母N对应的是Needs，也就是满足。做完这件事之后，就算感到疲劳和困倦，你依然会有满足感。比如，之前做咨询的时候，每次给客户汇报方案、被各种问题砸过来的时候，我都累到不想再继续了，然而结束之后，又觉得充满了成就感。杨丽萍说“跳舞就是跳舞最好的回报”，描述的就是这种感受。&nbsp;以上就是天赋的四个表现，了解到天赋的表现之后，你就可以开始有意识地去挖掘了。当然，你总结出这些事件之后，还需要再次提炼共性，比如我总结出这些事件的共性是数据分析，那么说明我的数据分析方面有很大天赋，所以就可以着力培养，以成为自己的核心竞争力。我曾经写过一篇文章，描述我利用自己的优势，挑选客户，成为晋升最快咨询顾问的故事，感兴趣的话可以跟班主任要链接。&nbsp;好了，讲完这些，你可能还是有个疑问：这些事件我要怎么发现呢？因为我们对自己的行为太熟悉，日常工作生活可能很难发现符合SIGN的特征，所以这里给两个方法，分别是向自己提问和向他人提问：&nbsp;1.&nbsp;问自己&nbsp;你可以通过问自己一些问题，帮自己找到符合天赋表现的事件。当然，问题还是围绕天赋的四个特征SIGN。&nbsp;第一类问题：自我效能S相关&nbsp;你认为，自己能够教别人什么？或者，别人常常向你请教什么？你跟他人聊天的时候，倾向聊什么？以及，聊什么话题你会更有自信？你在做什么事情的时候，不会感到焦虑和担心？&nbsp;第二类问题：本能I相关&nbsp;你在做什么事情的时候，很少拖延？长时间休假后，你最想念工作的哪个方面、哪个内容？你宁愿放弃休息时间，也要做的事情，是什么？&nbsp;第三类问题：成长/专注G相关&nbsp;有什么事情，让你沉浸其中忘记吃饭/睡觉？你在做什么事情的时候，会暂时忘记刷社交网络？你在做什么事情的时候，不容易感到疲倦和厌烦？&nbsp;第四类问题：满足N相关&nbsp;过去的工作和生活中，有什么让你获得巨大的成就感和满足感？&nbsp;2.&nbsp;问他人&nbsp;我们之前说过，天赋是天生的、下意识的，所以很多时候，你很难辨别出来。但是从别人的角度，他们跟自己有对比，会更容易帮你辨别。&nbsp;所以，你可以把这些基于SIGN模型的问题，发给你亲近的朋友或者同事，让他们帮你回答：&nbsp;你觉得，我身上有什么不同于别人的特质？你最欣赏或者佩服我的方面是什么？在你看来，我做什么事情的时候，看起来最兴奋？你曾经看到我做过哪件事情，让你印象深刻？&nbsp;在以下这些方面，你觉得我哪些更加擅长？思维方式：条理清晰、逻辑严密、脑洞很大、专注专业；沟通协调：化解冲突、争取资源、知人善任；计划执行：执行力强、追求完美、目标导向，等等。&nbsp;你会发现，你眼中的自己，和别人眼中的自己，常常有很大的差异。&nbsp;好了，关于天赋的方法，我们了解到这里。&nbsp;我们都应该听过一句话“大多数人的努力程度之低，根本达不到拼天赋”，这并不正确。虽然这句话是为了安慰我们不要怪先天条件，而要靠后天努力，初衷是好的。但天赋不是达到一定程度之后才发挥作用的东西，而是一个在起点就发挥作用的因素，它让你快速掌握某项能力，而快速掌握之后产生的成就感和信心，又会让你继续下去，从而形成一个良性循环。&nbsp;这里顺便说一下，努力固然重要，但没有方法的、无效的努力反而会让你丧失信心，是有害的。实际上，我自己是很努力的，圈外的学员也都很努力，否则有时间为什么不去玩游戏、而选择来上课呢？可关键问题是，我们都是一天24小时，无非是有人工作学习8小时、有人工作学习16小时，最多也是2倍的差异，可最后不同人的市场价值、能达到的高度，远远不是2倍，而是200倍、20000倍，而那些最成功的人，也并非智商超群、天赋异禀，那是什么因素导致的差异呢？方法一定是其中很关键的因素。&nbsp;所以我一直强调努力要有方法，而这些方法，并不需要你自己去摸索，前人早有很多总结，你只需要站在他们的肩膀上就可以了，就像今天所讲到的天赋一样。这也是我做圈外、做这门课程的原因，初衷之一，就是希望自己作为人才发展领域的专业人士，能够把这些研究和正确的方法，教给更多人，让我们付出同样时间的前提下，能有更多的效果和产出。&nbsp;好了，这一节，我们讲到天赋是隐藏能力，经过培养和练习之后才能转化为真正的能力。那么如何培养和练习呢？下一节，我们就来看看，有哪些方法，能够将知识内化成能力。 三种方法，将知识内化成能力 4&nbsp;本节学习收获：掌握将所学知识内化成能力的3个方法，盘活你脑中的知识&nbsp; 在课程正式开始之前，我先提个问题，我们第一节课介绍了冰山模型，在这几天里，你有没有用它来解决过问题呢？&nbsp;如果没有的话，那么冰山模型对你来说，就是没有用的“惰性知识”，它只是待在你的脑海里，在一些明明可以发挥作用的场合，却不能及时被调取出来，白白占据了你大脑的内存。&nbsp;陈铭在《奇葩说》中举过一个例子，很好地解释了知识和能力的关系。他说：&nbsp;水在零度的时候会结冰，这是一个知识，是对外部客观规律的归纳和总结。在未来的时间中，我在什么时候、把什么味道的水、变成什么味道的冰棒、卖给谁，叫做智慧和能力，它是指对知识的处理和运用。&nbsp;&nbsp;&nbsp;我在咨询公司的时候，很多客户都在自己所在的行业里摸爬滚打了几十年，行业知识和经验肯定比工作几年的咨询顾问丰富，但为什么我们能帮他解决问题、收取那么高的咨询费呢？这也是因为，咨询顾问掌握的是一套思维方式和思维能力，能够更好地用知识来解决问题，发挥每个知识的最大效用。&nbsp;所以，如果你只是知道冰山模型这个概念，但在实际的工作和生活中用不上它，没能让它成为自己思维的一部分，那就是没用的。那么，究竟该怎么做，才能让知识内化成能力，让自己的能力快速提升呢？今天给你三个方法：1.掌握20%的核心；2.知识和问题互相靠；3.做系统化训练。&nbsp;1.掌握20%的核心&nbsp;做咨询的时候，需要快速地在1周之内了解一个行业。很多人会觉得：咨询顾问很聪明，学习能力超强。&nbsp;但在我看来，只是因为他们能够拿到优质信息资源、所以掌握了那个领域的核心而已，倘若把这个核心教给任何一个智商尚可的人，他们也可以做到。&nbsp;不信的话，回想一下我们大学的考试，虽然一学期的课很复杂，但大多数人也是用考前一周的时间去突击的，只要抓住了核心，最后的考试成绩其实不会差。&nbsp;我们常说的“二八原则”，其实这里也适用：一个领域20%的核心内容，能够解决这个领域80%的问题。&nbsp;所以，掌握这20%的核心，就是我们快速提升的关键。无论是知识也好，能力也罢，想要快速提升，都是如此。那什么是20%的核心呢？&nbsp;分享一个故事。我在刚做咨询顾问的时候，有一次被项目经理狠批：你PPT为什么做得那么难看？有没有审美？&nbsp;当时非常沮丧，因为熬了无数个夜晚做出来的方案，最后却得到这样的评价。所以我下决心去美化一下PPT。&nbsp;先说结果：项目经理周五说的这话，我在后面周一的时候，PPT就全改了，彻底把她惊到了。后来这个事儿在公司广为流传，大概是：一个学习能力超强而且超级拼命的顾问，用2天时间提升了100页PPT的逼格。&nbsp;怎么做到的？其实很简单，我当时就是拿了一些高手的PPT，跟我自己的做对比，然后再问这些高手请教经验，最后找出了PPT美观的三个关键点：1）饱和度；2）边框；3）行间距。然后我把自己的PPT做了三个改动：1）把原先填充颜色改成半透明；2）把表格的边框改细；3）把字的行间距拉到1.5倍。这样改好，结合配色一点调整，逼格就高很多。&nbsp;这三点，其实就是让咨询PPT变得更加美观的那20%核心。&nbsp;当然，比起真正的PPT高手来说，我差得远，但我并不靠做PPT谋生，这20%已经够用了。&nbsp;上面说的是技能，其实能力也是一样的。比如，我们经常说一个人思维混乱，然后觉得思维混乱是个很大的事情，感觉一辈子都提升不了。但实际上，大部分的思维混乱，都是因为缺乏结构化思维，而结构化思维只要掌握三个特征就可以，包括主题鲜明、归类分组、逻辑递进，不管写作、演讲还是会议发言，做到这三点就可以显得思路很清晰。按照一定的方法论来训练，根据天赋不同，2周到2个月不等，就能有明显改变。这不是我瞎说，我写过文章、开过课程，按这个方式训练的没有一万也有八千。之所以取得这样的效果，是因为结构化思维属于思维的20%核心，而我说的3个特征，又是结构化思维的20%核心。&nbsp;但是，每个领域里面，哪些是那20%的核心，其实是需要这个领域的专家来指点的，因为在你对这个领域一无所知的情况下，你没有方向，绕一大圈也不知道门在哪里，等终于入门了才发现走了不少弯路。大多数的成功人士，都很擅长找“师傅”，他们都在自己的传记当中提到，受谁谁谁的启发和提携。而我理解的好师傅所起到的作用，除了提供资源之外，另一个重大作用就在于，他们会告诉你，一个领域里面最核心的是什么，从而让你快速入门。而我所认为的好书、好课程，除了需要大而全的教科书之外，也应该是这样的定位，不是把所有理论都照搬过来，而应该帮助读者和学员找到那20%，至于入门之后他是否需要或者愿意深度提升，那是他自己的选择。关于20%，圈外的公众号里面会有一些文章，涵盖了一些常见能力领域，这些文章都是提取了该领域里20%左右的核心，可以在班主任那里获取文章链接。&nbsp;2.知识和问题互相靠&nbsp;我们经常有一种感觉，平时明明学了很多知识，但在遇到问题的时候，苦思冥想，试图从记忆里找知识来解决问题，可就是想不出来，没有任何思路。但是，也有极少数人，学一个知识，就可以举一反三地解决很多问题。&nbsp;实际上，之所以在解决问题的时候想不起用什么知识，是因为知识和问题之间是脱节的，他们是分别存储的。比如你学习了马斯洛五层次需求的知识，你在学这个知识的时候，就没想过它可以用来解决什么样的问题，只是知道了一个概念，那么当你遇到团队管理问题的时候，自然也想不起来能用这个知识解决，也就是说，你的问题很难把你脑中的知识调用出来。这种现象，是造成我们所学的知识无法内化成能力的关键原因。&nbsp;那么，如何让知识和问题链接起来、解决问题的时候可以轻易调用知识呢？答案是：知识向问题靠，以及问题向知识靠。&nbsp;先说知识向问题靠，就是说，每看到一个知识的时候，就去思考这个知识可以用来解决什么问题。&nbsp;比如，你学习了马斯洛的五层次需求，就马上思考一下它可以用来解决什么问题。因为这个知识讲的是人类的需求，而我们跟任何人相处其实都需要知道对方的需求。所以你就会想到，它可以用来管理下属（分析他们的需求层次，并据此激励他们），也可以用来找另一半（分析你自己所处的需求层次，从而确定你需要什么样的人），还可以用来分析奢侈品为什么可以卖那么贵（买奢侈品，满足的不只是物质需求，还有被人尊重的需求等等）。&nbsp;这就是知识向问题靠。&nbsp;而问题向知识靠呢？就是当你遇到问题的时候，抛弃第一反应，不要先按照自己的思维定式来解决，而要去想有什么方法论模型可以用。&nbsp;为什么不能按照第一反应的方式解决呢？因为在我们碰到问题的时候，我们的下意识第一反应，是未经思考的，是在遵循我们过去的模式，但如果我们处理所有问题都靠过去的模式，那么刚刚学习的新知识、新解决方案，要怎么才能掌握呢？所以，试着抛开思维定式，用你学到的知识去解决，这样一来，你的知识就会被不断盘活，你解决问题的能力会越来越强。&nbsp;具体怎么落地呢？分享我的做法。当我看书或者学习课程看到一个很有用的理论或者模型，我会记下来，然后思考至少3个用该模型解决问题的场景，也一起记下来。下次当我遇到一些难题的时候，我不会下意识反应，而是翻一下这个笔记，对照一下，哪些方法模型能解决这个问题，如果是笔记中没有的场景，这个问题是某个模型的新场景，我就补充进去。长此以往，积累了很多知识和问题之间的链接，自己解决问题的能力也得到了极大提升。&nbsp;3.系统化训练&nbsp;为什么说要系统化训练呢？一方面，不同的能力并不是相互割裂的，它们之间是有关联的。比如说，你要提升自己的演讲能力。而演讲要做得好，首先需要结构化思维，你得表达清晰；在此基础上，你需要会讲故事，能够打动听众，而讲故事也是一种能力。再比如说，很多人说我表达不清晰，那我就去学表达，但表达其实本质上是大脑在说话，大多数人表达不清晰，并不是因为表达能力的问题，而是本身思维就不清晰，所以思维和表达得一起提升。所以说，能力的训练是需要系统化的，因为它们本身相互关联。&nbsp;另一方面，能力需要刻意练习，而刻意练习需要时间。我在前面说到的结构化思维的例子，虽然已经帮你挑出那20%最关键的部分了，但它也不是一蹴而就的，也是个系统提升。比如，1个月的计划中，先是每天练习讲三段式，再是练习提炼主题，然后是积累结构，基本上每天是不间断的。&nbsp;这样的系统训练需要一段时间的，但很多时候我们的习惯，是高估几天的变化，而低估几个月的变化，所以很难坚持系统化训练。&nbsp;比如说减肥，你这周有兴致就跑步2次，下周有兴致就节食1次，再下一周从外卖改自己做饭，之后再参加了几次减肥训练营。你会发现，几个月之后，也不会有什么变化。因为减肥是个系统工程，你得有一个3个月计划，按照计划，今天跑步、明天健身房，同时辅助饮食调整。学习是一样的，今天学点结构化思维，明天练一下演讲，很难有真正的提升。知识的学习是大脑增加了一段记忆，但能力的提升是行为和思维方式发生改变，而行为和思维方式是短时间内很难改变的。&nbsp;所以，圈外商学院里面，针对能力提升的学习，只做系统化学习项目，包括课程、练习及反馈，也有线上线下学习社群，整个学习持续4-8个月。效果如何呢？我在开学的时候，会寄给大家一封入学欢迎信，要求大家在毕业的时候给我回信。我收到过上百封回信，以及近千个微信消息，都提到说，原以为几个月很长，但真正结束后，回头看，没有想到几个月可以有这些改变。&nbsp;好了，总结一下，今天提到了将知识内化成能力的三个方法：掌握核心的20%、知识和问题互相靠以及系统化训练。具体到我们的行动中，如果我们有需要提升的能力，首先要先找到专业人士，了解这个领域的核心20%是什么，先去学习那20%；然后在学习过程中，思考各个知识点的应用场景，并记录下来，遇到问题再返回去找；最后，能力提升是个系统性过程，所以需要坚持至少1个月。&nbsp;我经常用开车来打比方，你拿着一本开车指南然后背下来，里面的知识背得再熟，一点价值都没有；你把指南里的知识落地，真正上车然后开起来，才是有价值的。知识不能被内化成能力，就像守着一本开车指南却不会开车一样，除了浪费大脑内存之外，毫无意义。互联网时代，我们要记住一句话：大脑不单是用来记忆的，更是用来思考的。&nbsp;好了，现在我们知道了如何通过学习将知识内化成能力，但学习说到底是一件反人性的事情，很难坚持，更何况是要系统化训练。实际上，学习这件事，如果纯靠意志力，的确是不可持续的，那如何能够让自己坚持学习呢？这个领域有什么样的研究和方法呢？我们将在下节课揭晓。这个方法不仅对学习有用，对任何需要坚持的正面行为，比如健身，都会非常有用。我们下一节再见！ 三大系统，让学习不靠意志力 5本节学习收获：学会掌控自己的三类方法，让你不靠意志力，也能坚持学习&nbsp; &nbsp;&nbsp;我们经常会听到诸如此类：如果坚持每天背20个单词，一年词汇量就接近8000了，基本是托福的词汇量；如果坚持每天写2000字，两个月就12万字了，就可以出一本书。&nbsp;我们都知道这个积少成多、长期坚持的道理，但是，有多少人真正坚持得了呢？&nbsp;上节课我们提到，能力提升比知识学习更难，当然，因为难所以才有价值，如果非常简单，就没什么竞争力了。但是，这么难的事情，要怎么才能坚持呢？&nbsp;靠意志力吗？我们都是这么想的，所以经常会说“xx很自律”“xx意志力惊人”。&nbsp;但实际上，因为人的意志力是有限的，任何让自己坚持的事情，都会消耗它，从而让你感觉非常累。比如你会发现，如果我们一段时间工作压力很大，就会更容易放弃健身等等良好习惯，因为我们的意志力在坚持工作这方面已经耗费光了，所以就没有多余的意志力用在坚持健身上了。&nbsp;学习也是一样，当你坚持学习的时候，不是“学习”这件事情累着你，而是“坚持”这件事情累着你了，因为意志力会耗费大量能量。&nbsp;而且在移动互联网时代，我们会发现，自己的意志力好像越来越薄弱。以前高中时期，能坚持学习2个小时，但现在看1小时书，就觉得如坐针毡。很简单，因为我们面对的诱惑更多了，游戏、短视频、微博等等这些，都比学习的诱惑力更大，只要我们脑子里有这些东西，就需要不断耗费我们的意志力来抵制他们，才能最终坚持学习，所以我们才会很累。&nbsp;威尔海姆·霍夫曼（Wilhelm Hofmann）主持的一项研究表明，人们醒着的时候，把大约1/4的时间用来抵制欲望。而这个研究是在BP机时代做的，近二十年间，移动互联网兴起带来的诱惑，比如游戏、短视频、段子等等，比过去上千年的诱惑加起来还要多，所以我们每天需要抵制更多欲望。这也是为什么，我们常常觉得，没做什么事情，也会感到很心累的原因。&nbsp;好了，诱惑那么多，意志力又不够用，那怎么办呢？今天我们就从行为改变的方法论角度，来讲讲，如何不纯靠意志力来学习。这个方法，不只是适用于学习，还适用于其他任何有点“反人性”的事情，比如健身、跑步等等。&nbsp;心理学家早就对我们的大脑做过研究，学界普遍认为，人类大脑内部有两个系统：理性和感性。感性跟情感有关，是天性和本能。而理性则跟理智有关，让我们能够深思熟虑。我们决定做任何事情的时候，都是这两部分在起作用。&nbsp;比如说，你在刷抖音，感性会告诉你“视频很有趣，继续刷吧，你会很快乐”，而理性却告诉你“别刷了，要去学习，否则将来没有前途”。&nbsp;理性和感性是你的内部因素，而做一件事情还有外部因素的影响，这就是情境。关于情境我打个比方，如果你周围都是胖子，那么你变胖的概率会大大增加。如果你周围人都爱学习，那么你也会变得更爱学习。&nbsp;所以，总结来说，如果要让我们能够坚持做一件事情，比如学习，并不是只能靠意志力的，其实有三个关键因素：理性上知道要学习、情感上愿意去学习、情境上制造适合学习的场景。接下来，我们从这三个方面去展开，看看有哪些方法，能让我们坚持做成一些事情，而不是白天堕落，晚上后悔然后发誓，第二天继续这个堕落、后悔和发誓的循环。&nbsp;1. 发挥理性的作用：树立明确目标&nbsp;假设我让你追一只猫，如果我跟你说：“目标在东北方向！”你能快速找到吗？很难。但如果跟你说：“目标在东北方向一公里处的圈外办公室！”那你更有可能会找到。所以，我们的目标需要足够明确。&nbsp;比如，你跟自己下了无数次决心：要多看书，不能再不学无术了。然后呢？你继续刷剧去了。但如果你跟自己说：每天晚上睡前看10分钟书。那么，你更有可能会做到。&nbsp;所以，当你有明确目标的时候，同样的事情会有完全不一样的效果，你会更容易坚持。&nbsp;这里给个数据，在圈外商学院的课程内，会有一个模块是专门用来写学习目标的。我们曾经做过一个数据分析，分析那些写目标的和不写目标的人，最后课程完成率有没有差异。最后的结果是，写目标的人的完成率是没有写的人的1.5倍。&nbsp;所以，给自己一个明确的目标，是你坚持学习的第一步。&nbsp;2. 发挥感性的作用：利用情绪冲动&nbsp;比如，如果我讲很多大道理，从理性的角度去说服你，应该给希望工程捐钱以支持失学儿童，你可能很难做出改变。但是，如果我给你一张失学儿童的照片，看到她渴望学校的眼神，你可能会被触动，然后做出了捐款行为。这就是情绪的力量。&nbsp;为什么化妆品、医美等等这样的产品，都在不断煽动女性对衰老的恐惧，因为恐惧是一种情绪，会让你有冲动付费。&nbsp;而能够促进你行为的情绪不只是恐惧，其实有很多种，比如愧疚感、认同感、成就感，等等。这里我给你建议几个利用情感的方法，用圈外过去所做的很多尝试为例——&nbsp;方法1-截止日期的紧迫感：&nbsp;豆瓣9.4分英剧《黑镜》的编剧查理·布洛克，收到过很多邮件，都是问他，怎么写出这么好的剧本。他回复大家说：“不要谈什么天分、运气，你需要的是一个截稿日，以及一个不交稿就能打爆你狗头的人，然后你就会被自己的才华吓到。”&nbsp;圈外商学院的课程，有个规定：在30天之内学完，你可以终身永久回看，而且可以看最新版本，因为我们课程会不断迭代；但如果你30天之内没有学完，课程就会关闭，哪怕你付了钱。很多人抱怨这个政策，但我们一直没改，因为我们看过数据，截止日前3天大家都在拼命学习和写作业，如果取消这个截止日期，谁会去马上学一个终身有效、没有截止日期的课程呢？所以，deadline是第一生产力。&nbsp;方法2-比较产生的焦虑感：&nbsp;举个我自己的例子，其实我在创业之前也纠结了很久，不知道自己能力是不是足够，总觉得没有准备好。当时我的好朋友，也是现在圈外的联合创始人杰西，就跟我说“你看你都这么大年纪了，现在创始人都很年轻，你再不创业就老了”，后来我就一咬牙出来了，也才有了现在的圈外同学。&nbsp;顺便说一句，我现在经常给很多人一个建议：你需要一个在关键时刻踹你一脚的人，因为人都是有惰性的。&nbsp;方法3-鼓励带来的成就感：&nbsp;在圈外，我们曾经做过一个对比，早期的产品是没有班主任服务的，也没有助教，那时候的完课率只有百分之十几。后来我们先尝试了给学员分班级、配备班主任，主要就是根据学员的学习情况鼓励他们，那时候还没有助教、学习游戏，但是完课率直接提升到了百分之五十多，基本就是社群和班主任鼓励的作用。&nbsp;当然，其他还有很多情感很有用，比如对未来的期待感，如果你是想从传统行业到互联网行业，想通过学习来实现，那么有一个已经成功转型、而且实现了2倍涨薪的人来告诉你，他是通过学习来实现的，然后给了你他的3个月学习计划，你是不是很有信心学习呢？&nbsp;3. 发挥情境的作用：创造学习环境&nbsp;好了，理性和情感说完，最后说说情境的作用。&nbsp;还记得我们前面举的例子吗？如果你周围的人都是胖子，那你减肥的成功率会低很多。&nbsp;这很容易理解，人是社会动物，我们会观察周围人的行为来调整自己的行为。&nbsp;最简单的，你去一个陌生的社交场合，你会多说话还是少说话、多吃还是少吃呢？大多数人的做法是，看周围人怎么做。&nbsp;学习也是一样的，很多人都发现，跟一群人一起讨论学习，会更容易坚持。&nbsp;原因很简单，爱学习爱思考的人并不多，现实生活中，大多数人都在看娱乐八卦，如果你在学习，会觉得自己很突兀。但是到了学习社群就不一样了，大家都在学习，你也会模仿其他人，这也是为什么，圈外的课程都有线上线下社群的原因，就是为了有这样一个氛围。&nbsp;情境里除了同伴因素以外，还有其他因素。举个例子，如果你比较容易被抖音干扰学习，那你把手机锁起来，制造一个专注的环境，这个问题就解决了。所以，如果想让你不看电视，最好的方法是别买电视；如果想让你少刷朋友圈，最好的办法是把小红点功能关掉，甚至，把朋友圈关掉；如果想让你别再剁手，最好的方法是把淘宝卸了，或者把信用卡额度冻结了。&nbsp;如果可以用环境，就不要用你的意志力来抵制欲望。&nbsp;好了，我们总结一下，学习这件事，是不能纯靠意志力的，因为意志力非常有限，非常耗费能量。所以，你得利用自己的理性和感性两大系统，结合情境，让你愿意学习：首先利用你的理性系统，设定非常清晰量化的目标；然后，利用自己的情绪冲动，包括焦虑感、成就感等等，去促进学习；最后，还要让自己处于一个适合学习的情境。&nbsp;2018年10月，在中国拥有近五千万职场用户的LinkedIn(领英)，做了一个调研，发布了一份《职场人转折点报告》。报告中有个有趣的发现：每月收入低于3000元的职场人加班时间最长，而相较之下，每月收入大于4万元的职场人学习时间最长。可以看出，能提升我们市场价值的，可能不是加班，而是学习。所以，希望你在掌握了这些方法之后，可以坚持学习提升。&nbsp;到这里，我们的课程已经完成了5小节，如果你走到了这里，恭喜你，因为大部分人可能会在前面几天放弃。&nbsp;之前的几小节，我们讲了如何选择适合的工作，选了工作之后如何投入时间以获得最大化价值，同时还给出了提升能力的方法，以及告诉你如何坚持学习提升。你有没有想过这些问题，为什么我们现在都在说要终身学习呢？以及，为什么个人要自己花钱花时间学习呢？为什么企业越来越不愿意培养人了？不仅不愿意培养人，招来人干了几年之后，甚至会裁人，导致我身边35岁的中年人每天都很焦虑，生怕遭遇中年失业。这些问题，我在最后一小节课程跟你讲，并且会教给你3个方法，让你今后，在这个快速变化的时代，依然保持竞争力。 三个建议，让你不做“定制化人才” 6 本节学习收获：学会3个“不变应万变”的方法，避免成为“企业定制化人才”。 我的一位中学同学，在某个耳熟能详的大外企做工程师。工作10年，接受了很多公司培训，还经常有国外出差的机会，自己的表现也一直都属于中上游。3年前，他所在的业务开始缩减人员，最近一个关系好的同事也离开公司去创业了，他也觉得自己要做些改变，打算转行。但是，信心满满地投了几十份简历，几乎没什么回音。唯一拿到的一个offer，对方公司开出的薪酬只有现在的70%。照理说，我这位同学也算是大公司的优秀人才，怎么出了公司，竟然找不到合适的工作呢？《国富论》里亚当·斯密提到的一个扣针工厂的例子：一个工人无论如何努力，一天也生产不了20枚扣针，但有了分工之后，经过前后十几道工序，每人每天平均可以生产48000枚扣针。这就是专业化分工的高效性！任何一家公司，从老板的角度肯定是要提高效率、多赚钱，所以必然走向专业化分工，把一个工作切成很多块，每个人都终日重复其中某一块，这样能提高效率、降低风险，同时也降低对人的依赖。但是，这对人才来说是灾难性的。因为亚当·斯密也说过“如果一个人的全部心思都用在一只扣针的十几分之一时，见识必然有限”。精细化分工的结果是，你成为了一个企业定制化人才，极端一点说，就像一颗螺丝钉，尺寸和材质只能用在一个产品上，挪到别处去，就成了废铁，被这个产品牢牢困住。这是我那位同学之所以跳槽失败的原因。那么，我们要如何避免被定制化呢？从我过去帮助7个行业的近百家头部企业设计人才管理体系的经验来说，我给你三个建议。第一，调整主体，给自己定好发展方向；第二，提升能力，让自己成为横向可迁移的人才；第三，提升认知高度，让自己成为纵向可拓展的人才。1、调整主体，给自己定好发展方向我之前公司做的一个调研数据很有意思：10年前，一个人在一家公司所待的时间是3-4年，而现在，一个人在一家公司平均只会待1年多。这是人才侧的数据，而从企业来说，我10多年前刚做咨询的时候，企业做战略规划都是5年甚至10年，而现在，能够拿得出清晰3年战略的企业，已经不多了。而中国企业的平均寿命不到3年。在这种情况下，企业没有任何动力培养人才，一方面人才只在公司平均待1年多，培养好之后还来不及给公司提供足够多的贡献，对企业来说根本不划算；另一方面，外部环境竞争激烈，培养人才所需要的时间，企业根本耗不起。所以，企业越来越倾向于用现成的人。而当所有企业都想用现成人才的时候，其实就是企业将过去所承担的人才培养成本，逐渐转移到了个人身上。在这种趋势下，个人不可能把安全感寄托于企业。所以，我们现在倡导所谓“终身学习”，不是因为人们这两年突然爱学习了，是因为学习变成了生存下去所必须做的事情。企业定制化人才越来越没有竞争力，只有主动学习、提升能力才能适应时代。怎么转移主体呢？听起来好像很虚，如何落地？很简单，当你进入一家公司的时候，就要想好：如果我离开这里，还能干嘛？就像我前面课程所说的，你去领英等等招聘网站上，搜索一下这个职位出去的人都在做什么，就知道将来是否有出路了。2、提升能力，让自己成为横向可迁移的人才亚马逊创始人贝佐斯曾说：“人们常问我，未来十年，什么会改变；人们几乎从来不曾问我，未来十年，什么不会变。”他觉得，这个世界不管怎么变，都很难想象，人们有一天会希望物品价格越高越好，物流速度越慢越好。所以，这两个因素就是不变的因素，做好这些，比每天追逐变化要有效得多。作为人才也是一样，要想不被企业定制化，让自己成为万能零件，不受环境影响，也是要找到那些不变的因素。那对我们来说，什么是那个不变的因素呢？就是我们之前课程提到的，可迁移能力。当然，不同发展阶段的能力要求有不同。在很多公司内部，针对不同阶段的员工，都会有不同的能力模型，晋升以及招聘的时候就是用这一套标准来筛人的，而且各家公司其实有很多共性，这就是可迁移能力。如果是职场新人，要成为资深员工或者主管，需要具备：独立思考的能力、多任务高效工作的能力、清晰表达的能力、基础的人际拓展能力。&nbsp;如果到了要带一个小团队、或者在公司内部管理一些项目的阶段，则需要具备：解决复杂问题和创新的思维能力、辅导和激励下属让团队提升效率的能力、在公开场合演讲表达能力、处理复杂人际冲突的沟通能力。而如果是成为管理者，开始带整个部门的时候，需要具备的能力包括：在思维方面，掌握战略思维以及理性的经济学思维；在效率方面，需要掌握一些运营和财务的知识，更好地配置资源；同时，需要掌握营销思维，贯穿在工作全流程中；最后，在人际方面，需要全面的领导力。圈外商学院用这套体系培养人，受到了很多企业的认可，都愿意来圈外商学院招人。目前圈外的L1、L2、L3学习项目，分别对应了上面这个能力体系。如果同学对商学院课程感兴趣，可以找班主任获取【商学院课程介绍】。3、提升认知高度，让自己成为纵向可拓展的人才上面讲的是提升可迁移能力，这样不局限在某个垂直领域。而除了横向可迁移之外，还得纵向可迁移，也就是说，提升自己的认知高度。就像亚当·斯密所说的，如果你全部精力都在某个产品的某个工序，见识一定是有限的，所以你得跳出这道工序，了解整个产品。你需要去思考：这个行业和公司的关键成功要素是什么？对用户对社会的价值是什么？你所在的部门和岗位，对公司的核心价值是什么？从更加宏观的角度去看问题，至少成为一个比螺丝钉更大的零件。而且在职场，职位越高，对专业的要求会降低，而对战略全局观、商业敏感度和领导力的要求是越来越高的。那如何去提高这些能力呢？&nbsp;大多数人的第一选择是去读个MBA，领英在2017年的报告显示：高达79%的职场白领都想过读MBA。但实际上，去读的只占中国职场人比例的不到1%。几十万的学费、2年的时间，都是极大的机会成本。圈外商学院的L3计划其实就是一个Mini-MBA项目，不同于那些只有音频视频的知识付费课程，而是纳入了真正顶尖商学院必备的案例教学法。我们应该是第一个做在线案例教学的在线商学院，用哈佛和中欧的原版案例，跟复旦、交大等商学院教授合作课程，加之麦肯锡前高管、著名投资人等等实战人士分享案例，6个月课程+企业实战，让每个职场人都能读一次“MBA”。这个项目跟其他不同，为了保证学员质量，采用了申请制，填写申请通过之后才能报名。我们应该是第一家受邀参加华语商学院最大体育赛事“玄奘之路戈壁挑战赛”的在线商学院，我们的学员跟长江、中欧等等商学院的EMBA们一起参赛，同走戈壁，是一个很好的交流和人脉链接。好了，总结一下这节课程，要想不成为“定制化人才”，我们需要：第一，调整主体，给自己定好发展方向；第二，提升能力，让自己成为横向可迁移的人才；第三，提升认知高度，让自己成为纵向可拓展的人才。到这里呢，你已经完成了这个课程的学习。我们稍微总结一下：我们学习了冰山模型，知道了自己为什么会不喜欢一份工作，以及怎么找到跟自己匹配的工作；接着，继续从冰山模型出发，分析应该把时间花在什么要素上面，才能有市场价值的提升，我们得出了提升能力的结论；然后我们通过两小节讲了能力如何提升，首先是找到自己的天赋，也就是隐藏的能力，其次是掌握3个方法、将学到的知识内化成能力；而要做到这些，离不开对学习的坚持，坚持学习很难，而意志力又很有限，所以要掌握理性、感性和情境三类方法。最后，关于如何应对未来的加速变化，答案是不要成为企业定制化人才。通过这6小节课程，我想要告诉你的是：无论你对未来迷茫也好、遇到发展瓶颈也好，其实都是有解决方案的。社会发展到今天，你所遇到的几乎每个问题，这个世界上都有人曾经成功解决过它，我们要做的，就是去学习，没有太多的问题需要我们重复造轮子。克林顿曾提到，世界上几乎每个问题都已经在某个地方被某个人解决，我们的挑战是找到那些有效的解决方案。接下来，如果你有兴趣继续学习，我会给你介绍一下圈外商学院的课程项目，包括好的跟不好的，你可以自己判断是否适合。我们的课程是开学后7天无理由退款的，如果你不是合适的人，最后退款，会增加我们的服务负担，所以我客观介绍，你谨慎选择。我们的课程特点：1. 体系化：我们的课程项目分成L1、L2、L3这三个阶段，学习周期分别是4个月、5个月和6个月。L1帮助你从职场新人变成资深员工，所以帮你解决工作效率、结构化思考等等问题；L2帮助你成为初级管理者，所以帮你解决提升影响力、辅导团队、高难度沟通等等问题；而L3是一个Mini-MBA项目。2.实用性：课程都是针对工作中各种具体的问题进行设计的。每个课程都配备了选择题、实践题，并且有助教反馈，帮助你真正解决问题。另外，每个课程都会有案例练习，L1和L2来自于工作场景，L3的案例来自哈佛与中欧。最后，L2和L3会有实战项目，真实地帮一家企业解决营销、管理等方面的问题，丰富自己的履历。3.重视人脉链接：我们会提供圈外校内以及其他传统商学院的人脉资源，包括各企业的中高层、CEO等。在其他知识付费类的课程里，你很难认识到你的同学，但在圈外，会有线上校友录、社群和线下学习活动更直接地链接人脉。我们在北美和全国有14个城市校友会。4.受企业认可：因为注重实战，以及课程直接针对用户的职业发展，所以圈外课程跟知识付费不一样的是，能够被企业认可。目前上汽、复星等头部企业都跟圈外合作，用我们的课程培养他们的关键员工。关于圈外课程不好或者可能不适合你的地方：如果你的学习是为了看一看，而没有目的，那么不建议选择；如果你不愿意参与讨论和练习，只是听听，也不建议选择，这对你不划算；如果你认为，坐等报个课程就走上人生巅峰，更不建议选择，因为我们需要你也付出。马斯洛说：“教育是让一个人成为最好版本的自己”，给自己一个机会，用几个月的时间，真正用正确的方法，来训练一下自己，看看自己最好的状态到底是什么样的！“早点遇到圈外就好了”，这是圈外学员常说的一句话。实际上，你在听我讲话的这段时间，我就在你的生命中留下了痕迹，所以很高兴遇到你，期待我们再次相遇！]]></content>
  </entry>
  <entry>
    <title><![CDATA[mac下php手动编译debug安装会碰到的问题]]></title>
    <url>%2F%2Fphp-yuan-ma-jie-du%2Fcjz9ec8n8000ed58wmeytkiqg.html</url>
    <content type="text"><![CDATA[mac 下 php手动编译 debug 安装会碰到的问题 下载7.1.0版本php源码后进行编译 1./configure --prefix=/usr/local/php7.1.0 --enable-debug --enable-fpm --with-iconv=/usr/local/lib/libiconv --with-config-file-path=/usr/local/php7.1.0/etc mac 需要先切换管理用户 sudo su 再执行 make &amp;&amp; make install 如果碰到一些错误, 请把错误内容 分段 挑选关键词百度或Google 多试试提供的解决方法; 列出两个比较坑的错误解决流程 Undefined symbols for architecture x86_64:“_libiconv”, referenced from: 12345678910111213141516171819202122232425262728293031Undefined symbols for architecture x86_64: &quot;_libiconv&quot;, referenced from: _zif_iconv_substr in iconv.o _zif_iconv_mime_encode in iconv.o _php_iconv_string in iconv.o __php_iconv_strlen in iconv.o __php_iconv_strpos in iconv.o __php_iconv_appendl in iconv.o _php_iconv_stream_filter_append_bucket in iconv.o ... &quot;_libiconv_close&quot;, referenced from: _zif_iconv_substr in iconv.o _zif_iconv_mime_encode in iconv.o _php_iconv_string in iconv.o __php_iconv_strlen in iconv.o __php_iconv_strpos in iconv.o __php_iconv_mime_decode in iconv.o _php_iconv_stream_filter_factory_create in iconv.o ... &quot;_libiconv_open&quot;, referenced from: _zif_iconv_substr in iconv.o _zif_iconv_mime_encode in iconv.o _php_iconv_string in iconv.o __php_iconv_strlen in iconv.o __php_iconv_strpos in iconv.o __php_iconv_mime_decode in iconv.o _php_iconv_stream_filter_factory_create in iconv.o ...ld: symbol(s) not found for architecture x86_64clang: error: linker command failed with exit code 1 (use -v to see invocation)make: *** [libs/libphp7.bundle] Error 1 按照[同类问题](https://stackoverflow.com/questions/40167324/php-compile-fails-with-undefined-symbols-for-architecture-x86-64-libiconv-on-ma)的解决方法 在解决方法中搜索的关键词你如果搜索不到需要改成`EXTRA_LDFLAGS_PROGRAM` 或者拆分一下搜索 然后删除解决方法说的内容 记得前面加上 - ![](https://resource.fenxiangy.com/2019/08/08/15651647274096.jpg!markdown)https://bugs.php.net/bug.php?id=71343https://juejin.im/entry/5b87a081f265da434a1fd98a]]></content>
      <categories>
        <category>PHP源码解读</category>
      </categories>
      <tags>
        <tag>源码安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php中的变量-源码解读]]></title>
    <url>%2F%2Fphp-yuan-ma-jie-du%2Fcjz9ec8nj000zd58wkpg6h3jo.html</url>
    <content type="text"><![CDATA[变量字符串 在定义字符串 赋值给变量, 这个变量gc.u.v.type=6为字符常亮 由此可得字符常亮类型. 不手动创建内存去指向. 赋值变量赋值给另外一个变量 对于简单类型, 如: int null 会直接复制. 对于复杂类型 如 string object 会在写时复制 数组 数组变量 数组有两个类型: packed Array(索引数组) 和 Hash Array(非索引数组) , packed 类型只有两个索引数组 而 packed 则 有八个索引数组. - 当数组中的申键超过8个则会进行`处理`申请增加为`8+8`个桶数组 - `unset`并不会删除数组所占用的内存, 而是类型变为`is_undefined`观看教程:变量基础源码解析]]></content>
      <categories>
        <category>PHP源码解读</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mqtt协议理解]]></title>
    <url>%2F%2Fnote%2Fmqttprotocol.html</url>
    <content type="text"><![CDATA[mqtt协议理解标签（空格分隔）： mqtt 这个协议因为公司需要做物联网方面的东西, 去工厂里面向技术人员讨论告诉我需要的一些技术,让我去琢磨. 上图很好的描述了mqtt在物联网中使用范围 由于物联网的环境是非常特别的，所以MQTT遵循以下设计原则： 精简，不添加可有可无的功能。 发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递。 允许用户动态创建主题，零运维成本。 把传输量降到最低以提高传输效率。 把低带宽、高延迟、不稳定的网络等因素考虑在内。 支持连续的会话控制。 理解客户端计算能力可能很低。 提供服务质量管理。 假设数据不可知，不强求传输数据的类型与格式，保持灵活性。 这些也算是它的优点. 科普一下mqtt 一部分引用别的文章,加上我的理解; 发布/订阅模式 与请求/回答这种同步模式不同，发布/定义模式解耦了发布消息的客户（发布者）与订阅消息的客户（订阅者）之间的关系，这意味着发布者和订阅者之间并不需要直接建立联系。打个比方，你打电话给朋友，一直要等到朋友接电话了才能够开始交流，是一个典型的同步请求/回答的场景；而给一个好友邮件列表发电子邮件就不一样，你发好电子邮件该干嘛干嘛，好友们到有空了去查看邮件就是了，是一个典型的异步发布/订阅的场景。熟悉编程的同学一定非常熟悉这种设计模式了，因为它带来了这些好处： 从上面可以知道: 发布者与订阅者不必了解彼此，只要认识同一个消息代理(服务端)即可。发布者和订阅者不需要交互，发布者无需等待订阅者确认而导致锁定。发布者和订阅者不需要同时在线，可以自由选择时间来消费消息(这个要注意消息类型)。 ps:其实这种可以用生活中使用的微信形象解释这种 消息模式 :甲给乙发送一个消息;(其中就相当于甲发布了一个消息,而发布消息的目标是乙订阅的主题,只是这个主题是乙收消息的主题,甲传过来的消息可以分解为:发送人,发送的消息这样的参数) 乙不需要在线,但是在线就可以接收; 乙给甲发消息;甲订阅了个接收消息的主题,而乙就是发到这个主题中![消息发送订阅][3] 主题 MQTT是通过主题对消息进行分类的，本质上就是一个UTF-8的字符串，不过可以通过反斜杠表示多个层级关系。主题并不需要创建，直接使用就是了。主题还可以通过通配符进行过滤。其中，+可以过滤一个层级，而*只能出现在主题最后表示过滤任意级别的层级。举个例子： building-b/floor-5：代表B楼5层的设备。 +/floor-5：代表任何一个楼的5层的设备。 building-b/*：代表B楼所有的设备。注意，MQTT允许使用通配符订阅主题，但是并不允许使用通配符广播(发送消息)。 通配符: 主题层级分隔符: / / 被用来分割主题树的每一层，并给主题空间提供分等级的结构。当两个通配符在一个主题中出现的时候，主题层次分隔符的使用是很重要的。 ps:类似于新闻分类中的结构 / 全球新闻/中国新闻/码农新闻 单层通配符+ + 只匹配主题的一层。比如说，finance/stock/+匹配finance/stock/ibm和finance/stock/xyz，但是不匹配finance/stock/ibm/closingprice。另外，因为单层通配符只匹配1层，finance/+不匹配finance。 单层通配符可以被用于主题树的任意层级，连带多层通配符。它必须被用在主题层级分隔符/的右边，除非它是指定自己。因此，+和finance/+都是有效的，但是finance+无效。单层通配符可以用在主题树的末端，也可以用在中间。比如说，finance/+和finance/+/ibm都是有效的。 ps:匹配一层就是匹配 全球新闻/ 而订阅 码农新闻 的人并不能收到发送给 全球新闻/ 这个有通配符的主题的信息 多层通配符: # # 是一个匹配主题中任意层次数的通配符。比如说，如果你订阅了finance/stock/ibm/#，你就可以接收到以下这些主题的消息。 1234&gt;finance/stock/ibm&gt;finance/stock/ibm/closingprice&gt;finance/stock/ibm/currentprice&gt; 多层通配符有可以表示大于等于0的层次。因此，finance/#也可以匹配到单独的finance，在这种情况下#代表0层。在这种语境下主题层次分隔符/就没有意义了。因为没有可以分的层次。 多层通配符只可以确定当前层或者下一层。因此，#和finance/#都是有效的，但是finance#不是有效的。多层通配符一定要是主题树的最后一个字符。比如说，finance/#是有效的，但是finance/#/closingprice是无效的。 ps:多层匹配就是匹配 全球新闻 下的所有子主题 订阅 码农新闻 的人能收到发送给 全球新闻/# 这个有通配符的主题的信息 主题语法和用法 当你建立一个应用，设计主题树的时候应该考虑以下的主题名字的语法和语义： 主题至少有一个字符长。 主题名字是大小写敏感的。比如说，ACCOUNTS和Accounts是两个不同的主题。 主题名字可以包含空格。比如，Accounts payable是一个有效的主题。 以/开头会产生一个不同的主题。比如说，/finnace与finance不同。/finance匹配”+/+”和/+,但不匹配+ 不要在任何主题中包含null（Unicode \x0000）字符。 以下的原则应用于主题树的建造和内容 在主题树中，长度被限制于64k内但是在这以内没有限制层级的数目 。 可以有任意数目的根节点；也就是说，可以有任意数目的主题树。 服务质量 为了满足不同的场景，MQTT支持三种不同级别的服务质量（Quality of Service，QoS）为不同场景提供消息可靠性： 级别0：尽力而为。消息发送者会想尽办法发送消息，但是遇到意外并不会重试。 级别1：至少一次。消息接收者如果没有知会或者知会本身丢失，消息发送者会再次发送以保证消息接收者至少会收到一次，当然可能造成重复消息。 级别2：恰好一次。保证这种语义肯待会减少并发或者增加延时，不过丢失或者重复消息是不可接受的时候，级别2是最合适的。 服务质量是个老话题了。级别2所提供的不重不丢很多情况下是最理想的，不过往返多次的确认一定对并发和延迟带来影响(不适合api)。级别1提供的至少一次语义在日志处理这种场景下是完全OK的，所以像Kafka这类的系统利用这一特点减少确认从而大大提高了并发。级别0适合鸡肋数据场景，食之无味弃之可惜，就这么着吧。 ps:所以还是用级别1写api吧.0有点不稳妥,万一哪天发送个表白消息到妹子那里,妹子没收到造成不回复你.你还以为妹子不同意,或者默认… 消息类型MQTT拥有14种不同的消息类型(报文的类型)： 1234567891011121314CONNECT：客户端连接到MQTT代理CONNACK：连接确认PUBLISH：新发布消息PUBACK：新发布消息确认，是QoS 1给PUBLISH消息的回复PUBREC：QoS 2消息流的第一部分，表示消息发布已记录PUBREL：QoS 2消息流的第二部分，表示消息发布已释放PUBCOMP：QoS 2消息流的第三部分，表示消息发布完成SUBSCRIBE：客户端订阅某个主题SUBACK：对于SUBSCRIBE消息的确认UNSUBSCRIBE：客户端终止订阅的消息UNSUBACK：对于UNSUBSCRIBE消息的确认PINGREQ：心跳PINGRESP：确认心跳DISCONNECT：客户端终止连接前优雅地通知MQTT代理 搭配一个我在测试时所分析的服务器的消息日志更清晰看到使用: 1234567891011121314151617181920212223242526272829303132333435New connection from 192.168.1.166 on port 1883.1520560007: New client connected from 192.168.1.166 as 036914380929367040071489983908 (c1, k60).-新的连接 客户端连接指定的ClientID为036914380929367040071489983908 清除session k60: 表示keep-alive=60s1520560007: Sending CONNACK to 036914380929367040071489983908 (0, 0)-发送连接ACK包给客户端 1520560007: Received SUBSCRIBE from 036914380929367040071489983908-服务器收到一个来自ClientID为036914380929367040071489983908的订阅请求 1520560007: SN69143809293670ctr (QoS 0)-服务器识别036914380929367040071489983908订阅的主题为 SN69143809293670ctr，指定的QOS=0遗嘱保留被设置为 0，服务端必须将遗嘱消息当作非保留消息发布1520560007: 036914380929367040071489983908 0 SN69143809293670ctr-给ClientID=036914380929367040071489983908客户端发送订阅SN69143809293670ctr ACK回包1520560007: Sending SUBACK to 036914380929367040071489983908-服务器发送内容给客户端日志1520560017: Received PUBLISH from 036914380929367040071489983908 (d0, q0, r0, m0, &apos;SN69143809293670state&apos;, ... (99 bytes))-服务器正在发送一个消息给ClientID=036914380929367040071489983908的客户端，消息体大小为99 bytes，消息主题为‘SN69143809293670state’(d0, q2, r0, m0)的解释, 以下参数具体含义，参考MQTT协议 d: 表示mqtt报头的DUP字段 q: 表示的QOS字段 r: 表示的是RETAIN m: 表示的是消息ID,即mid ps:这个东西可以参考一下官方文档; 传送门 MQTT代理(算是服务端了)市面上有相当多的高质量MQTT代理，其中mosquitto是一个开源的轻量级的C实现，完全兼容了MQTT 3.1和MQTT 3.1.1。下面我们就以mosquitto为例演示一下MQTT的使用。环境是百度开放云的云服务器以及Ubuntu 14.04.1 LTS，简单起见MQTT代理和客户端都安装在同一台云服务器上了。centos安装方法 首先SSH到云服务器，安装mosquitto以及搭配的客户端：apt-get install mosquittoapt-get install mosquitto-clients 现在在云端模拟云服务，订阅某办公楼5层的温度作为主题： mosquitto_sub -d -t ‘floor-5/temperature’Received CONNACKReceived SUBACKSubscribed (mid: 1): 0 然后另外打开一个SSH连接，模拟温度计发送温度消息：mosquitto_pub -d -t ‘floor-5/temperature’ -m ‘15’Received CONNACKSending PUBLISH (d0, q0, r0, m1, ‘floor-5/temperature’, … (2 bytes)) 此时回到第一个SSH客户端可以看到信息已经接收到了，之后便是心跳消息： Received PUBLISH (d0, q0, r0, m0, ‘floor-5/temperature’, … (2 bytes))15Sending PINGREQReceived PINGRESP 需要注意的是mosquitto客户端默认使用QoS 0，下面我们使用QoS 2订阅这个主题： mosquitto_sub -d -q 2 -t ‘floor-5/temperature’Received CONNACKReceived SUBACKSubscribed (mid: 1): 2 切换到另外SSH连接然后在这个主题里面发送温度消息： mosquitto_pub -d -q 2 -t ‘floor-5/temperature’ -m ‘15’Received CONNACKSending PUBLISH (d0, q2, r0, m1, ‘floor-5/temperature’, … (2 bytes))Received PUBREC (Mid: 1)Sending PUBREL (Mid: 1)Received PUBCOMP (Mid: 1) 此时回到第一个SSH客户端可以看到信息已经接收到了，以及相应的多次握手消息： Received PUBLISH (d0, q2, r0, m1, ‘floor-5/temperature’, … (2 bytes))Sending PUBREC (Mid: 1)Received PUBREL (Mid: 1)15Sending PUBCOMP (Mid: 1) 至此我们初步了解了MQTT的基本知识！接下来会发布mqtt在php和node.js中的使用文章,敬请期待;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>mqtt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[supervisor 进程管理工具 (监听、启动、停止、重启一个或多个进程或自动重启)]]></title>
    <url>%2F%2Fnote%2Fsupervisor-process-management-tool-listen-start-stop-restart-one-or-more-processes-autorestart.html</url>
    <content type="text"><![CDATA[教程方向: 快速上手, 解决使用中遇到的一些问题使用环境: Centos7.2 安装:yum install supervisor 配置安装好后在/etc/会生成一个supervisord.conf文件及一个supervisord.d文件目录 Supervisord.conf是一些默认配置，可自行参考一些配置文件教程修改 我们主要修改 /etc/supervisord.conf 文件的最后一行: 12[include]files = relative/directory/*.ini ;可以指定一个或多个以.ini结束的配置文件 这里配置的是引入型配置, 会自动引入配置的目录下的配置文件 注意：[include]默认配置是制定.ini，因个人习惯命名为.conf文件，因此修改配置如下： 我们将配置目录改为自己想要的目录下后, 在目录下建立配置文件, 以frpc 为例. /root/supervisord_conf/frpc.ini 1234567[program:frpc]command=/home/vagrant/frp/frp/frpc -c /home/vagrant/frp/frp/frpc.iniuser=rootautostart=trueautorestart=truestderr_logfile=/home/vagrant/frp/frp/err.logstdout_logfile=/home/vagrant/frp/frp/out.log 其他配置文件对应参考注释: 12345678910111213[program:usercenter]directory = /home/Leon/projects/usercenter ; 程序的启动目录command = gunicorn -w 8 -b 0.0.0.0:17510 wsgi:app ; 启动命令autostart = true ; 在 supervisord 启动的时候也自动启动Startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了autorestart = true ; 程序异常退出后自动重启Startretries = 3 ; 启动失败自动重试次数，默认是 3user = Leon ; 用哪个用户启动redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 falsestdout_logfile_maxbytes = 20MB ; stdout 日志文件大小，默认 50MBstdout_logfile_backups = 20 ; stdout 日志文件备份数; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile = /data/logs/usercenter_stdout.log 注意: 配置中所指向的文件需要提前存在,否则会遇到错误. 启动并运行 执行: supervisord -c /etc/supervisord.conf 启动supervisord服务端 查看 supervisord 是否在运行： ps aux | grep supervisord 可能会碰到的错误: python 不推荐使用的包 12 /usr/lib/python2.7/site-packages/supervisor/options.py:383: PkgResourcesDeprecationWarning: Parameters to load are deprecated. Call .resolve and .require separately.return pkg_resources.EntryPoint.parse(&quot;x=&quot;+spec).load(False) 这个打印并不影响使用,如果想解决这个错误可以参考 github issues 重复启动错误 supervisorctl unix:///var/run/supervisor.sock refused connection 说明 已经启动 需要执行 supervisorctl shutdown终止进程再启动 开启了supervisord后需要使用 supervisorctl 管理 开启所有进程守护 supervisorctl start all 再执行 supervisorctl status 会看到: 12 [root@localhost supervisord_conf]# supervisorctl statusfrpc RUNNING pid 7989, uptime 0:10:15 其他命令 1234567891011121314$ supervisorctl status$ supervisorctl stop frpc$ supervisorctl start frpc$ supervisorctl restart frpc$ supervisorctl reread$ supervisorctl update解释:&gt; status # 查看程序状态&gt; stop usercenter # 关闭 usercenter 程序&gt; start usercenter # 启动 usercenter 程序&gt; restart usercenter # 重启 usercenter 程序&gt; reread ＃ 读取有更新（增加）的配置文件，不会启动新添加的程序&gt; update ＃ 重启配置文件修改过的程序 参考资料官方文档摘抄摘抄感觉不错]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发文档案例]]></title>
    <url>%2F%2Ftechnology-php%2Fdevelopment-document-case.html</url>
    <content type="text"><![CDATA[能愿动词为了避免歧义，文档大量使用了「能愿动词」，对应的解释如下： 必须（Must） - 只能这样子做，请无条件遵循，没有别的选项；绝不（Must Not）- 严令禁止，在任何情况下都不能这样做；应该（Should） - 强烈建议这样做，但是不强求；不应该（Should Not） - 强烈建议不这样做，但是不强求；可以（May） - 选择性高一点，在这个文档内，此词语使用较少； 开发流程规范: 应该使用自定义表单验证类,避免方法体过多类似功能代码段. 编写方法时应该声明返回类型 12 `public function create(Create $request): JsonResponse &#123;` 每个方法 必须 写上规范注释. 用户信息访问 应该 使用Auth门面, Auth已经过框架自动载入,具体使用方法参照现有代码. 应该 使用一个return 进行数据返回. 固定值访问应该 使用config()访问语义化词汇获得 如config(&#39;common_config.premium.min&#39;). 编写业务代码时遵循依赖框架原则,框架可以提供便利的尽量使用框架提供的功能. controller层仅作为基础判断使用,繁杂业务逻辑 应该 在Service层进行处理. 对存入数据的操作应该使用模型处理. 对一对多,多对多,多对一等模型数据访问时,尽量 使用框架自带的模型关联功能 关键性操作流程 应该 注入 事件 方便业务功能. 数据库表增删改 必须 使用数据库迁移 创建表后应该编写相应的数据工厂文件. 开发时应该先编写对应的单元测试. 应该 对表单数据进行类型校验,可以在表单验证中加上. 其他规范应该参照: Laravel 项目开发规范 接口 请求 接口 必须 统一使用api路由, POST请求统一放置在POST请求路由组; POST 请求路由 必须 使用 post 路由前缀, 中间件应该 使用与之相对的中间件 表单校验:接口路由指向的方法中请求信息参数 必须 使用自定表单验证类依赖注入校验表单填写是否正确, 自定义表单验证类中 应在类体中 使用 use UnifiedFormat; 处理表单验证类自动处理的返回内容适用到项目. Api的路由 必须 使用 name 方法标注, 标注中以 . 分隔, 标注代表着此接口的权限管理项的标注, 用于后期添加权限; 注意标注的末尾动作如下表格, 其他行为应该使用功能翻译英文标记 Api.前缀.功能(英文并可以多个 . 分隔).操作词 动词 描述 是否幂等 show 获取资源，单个 是 index 获取资源，多个 是 create 创建资源 否 PATCH 更新资源，客户端提供部分的资源数据 否 DELETE 删除资源 是 应该 使用 api 资源 返回数据资源. 响应 响应使用Res门面 use Res; 可使用具体方法在 app/Http/Controllers/Auth/Api/ResponseMsg.php 具体使用规则参考部分接口控制器代码 注意事项 使用复杂多表查询时注意软删除和一些模型无感知提供的功能的处理. 编写代码之前 应该 读懂 框架核心架构 api系统剥离只需要修改auth config/auth.php defaults=&gt;guard 三维数组中 web 变为 otcapi, apiverify中间件中handle方法 注释内容开启, 未注释内容注释]]></content>
      <categories>
        <category>PHP技术栈</category>
      </categories>
      <tags>
        <tag>开发文档案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[larval-admin拓展-使用备注]]></title>
    <url>%2F%2Ftechnology-php%2Flarvaladmin-extension-use-notes.html</url>
    <content type="text"><![CDATA[主要布局类Encore\Admin\Form类用于生成基于数据模型的表单，先来个例子，中数据库有movies表 Encore\Admin\Grid类用于生成基于数据模型的表格，先来个例子，中数据库有movies表 Model-grid默认有两个行操作编辑和删除，可以通过下面的方式关闭它们： Model-grid内置了很多对于列的操作方法，可以通过这些方法很灵活的操作列数据。 在model-grid的头部默认有批量删除和刷新两个操作工具，如果有更多的操作需求，model-grid提供了自定义工具的功能,下面的示例添加一个性别分类选择的按钮组工具。 Model-grid提供了一系列的方法实现表格数据的查询过滤： Model-form使用laravel的验证规则来验证表单提交的数据： Model-form目前提供了下面几个方法来接收 保存 回调函数： Encore\Admin\Show用来显示数据详情，先来个例子，中数据库有posts表： 通过可以model-tree来实现一个树状组件，可以用拖拽的方式实现数据的层级，排序等操作，下面是基本的用法。 在页面调用下面的方法，它将会调用toastr组件，在页面的右上角添加一条浮动的提示 Encore\Admin\Widgets\Box用来生成box组件： 使用方式 创建模型对应的增删改查控制器和模型 php artisan admin:make UserController --model=App\\User 在 web.php 中添加资源访问路由 $router-&gt;resource(&#39;users&#39;, UserController::class); 在后台系统 链接:/admin/auth/menu 中添加左侧菜单栏连接 剩下的工作就是构建数据表格和表单了，打开 app/Admin/Contollers/UserController.php,找到show()、grid()和form()方法，然添加构建代码更多详细使用请查看model-grid和model-form。 上手感触 在使用这个后台系统中, 如果按照设计图来弄不是太理想和方便, 例如表单太长只能用自带的 选项卡切换分组方式 : model-form-tab 如果表单元素太多,会导致form页面太长, 这种情况下可以使用tab来分隔form: 对于列和行 属于栅栏式布局 由于有些需求效果可能还需要做接口]]></content>
      <categories>
        <category>PHP技术栈</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云日志服务监控访问日志]]></title>
    <url>%2F%2Fnote%2Falibaba-cloud-log-service-monitors-access-logs.html</url>
    <content type="text"><![CDATA[添加日志服务 网址 点击创建Project 名称填好,所属区域选择需要监控的服务器的所在区域 接下来会出现弹出窗: 点击创建,或不小心关掉 点击名称进入下列2图界面 创建Logstore 这些根据提示填写好就行了. 数据接入 点击确认会出现此框点击数据接入向导,如果没有在2图数据接入想到下面有个按钮点几下 选择你需要的 - 配置规则. 这里要注意的只有日志路径, 注意仔细看备注.我的是: 第一个选项:/wwwlogs 第二个选框: *.log 如果担心自己获取到了,但是不显示也不知道出现什么问题,那就展开高级选项按照如图配置 - 填写好后点击下一步这一步比较重要,是能不能获取到日志的关键 关于机器组:需要用到阿里云的教程搭建个日志服务 - 点击创建机器组 - 点击帮助 进入https://help.aliyun.com/document_detail/28982.html?spm=5176.2020520112.116.d11.8c2434c0IPMoLR 安装Logtail; - 点击安装方式中的一个 我选的是阿里云内网,因为是阿里的机器 - 执行命令安装 安装成功 - 填写信息: 根据日志服务里选择的区域,再填入ip - 随后点击应用到机器组 - 进入机器组列表 机器的操作中的查看状态 心跳ok就没问题 监控分析 随后点击日志库: - 点击查询分析下的查询: 点确定 - 右上角有开启索引 - 出现这个,我的是nginx所以点nginx模板 然后等待一分钟左右,期间可在这里点监控 - 如果没有数据检查: 点击蓝色名字配置 左边有些选项均有文档,仔细看]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel服务提供者和门面及契约整理]]></title>
    <url>%2F%2Fnote%2Flaravel-service-provider-and-facade-contract.html</url>
    <content type="text"><![CDATA[标签（空格分隔）： laravel 服务提供者通俗意思是:你家需要水,服务提供者送水的;服务提供者生成后的代码 Contracts, ServiceContainer, ServiceProvider, Facades关系概念Contracts 合同，契约，也就是接口，定义一些规则，每个实现此接口的都要实现里面的方法 ServiceContainer 实现Contracts,具体的逻辑实现 ServiceProvider ServiceContainer的服务提供者，返回ServiceContainer的实例化，供其他地方使用，可以把它加入到app/config的provider中，会被自动注册到容器中 Facades 简化ServiceProvider的调用方式，而且可以静态调用ServiceContainer中的方法 php artisan make:provider FooServiceProvider 123456789101112131415161718192021222324252627namespace App\Providers;use Illuminate\Support\ServiceProvider;use App\lib\Tools\FooBar\FooBar;class FooServiceProvider extends ServiceProvider&#123; /** * Bootstrap the application services. * * @return void */ public function boot() &#123; // &#125; /** * Register the application services. * * @return void */ public function register() &#123; &#125;&#125; 其中boot在框架加载初期就载入就提供,如果你提供的水还需要矿物质什么的(框架内一些依赖) 就不要在这里进行提供; 在一个继承服务提供者的文件内boot方法register方法都可以使用 123$this-&gt;app-&gt;bind(&apos;test&apos;,function()&#123; return new Test();&#125;); 方式提供依赖这种写法理解思路可以参照:链接 在平时方法中使用: 1234567public function two($id=null)&#123; //从系统容器中获取实例化对象// $myfoo = app(&apos;test&apos;);// app()-&gt;make(&apos;test&apos;); $myfoo = \App::make(&apos;test&apos;); echo $myfoo-&gt;get();&#125; 或在 方法参数中加上依赖地址或名称; 123use App\lib\Tools\FooBar\Test;public function index(Test $test) 根据文章:地址整理思路 门面门面定义 123456789101112namespace App\CustomFacades;use Illuminate\Support\Facades\Facade;class Foo extends Facade&#123; protected static function getFacadeAccessor() &#123; return &apos;test&apos;; &#125;&#125; 继承Illuminate\Support\Facades\FacadegetFacadeAccessor()中return ‘test’代表服务提供者代码中 123$this-&gt;app-&gt;bind(&apos;test&apos;,function()&#123; return new Test();&#125;); 的test 在app.php aliases 数组中添加‘Foo’ =&gt; App\CustomFacades\Foo::class, 契约参考网址:https://www.jb51.net/article/135189.htmhttps://www.cnblogs.com/redirect/p/6087810.htmlhttp://laravelacademy.org/post/769.htmlhttps://www.cnblogs.com/cyforever/p/6139109.html]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对接币种钱包 资料整理]]></title>
    <url>%2F%2Fnote%2Fdocking-currency-wallet.html</url>
    <content type="text"><![CDATA[https://blog.csdn.net/rejames/article/details/82884508 https://github.com/aceat64/EasyBitcoin-PHP https://blog.csdn.net/wudwolf/article/details/79190084 https://bitcoin.org/en/developer-reference#raw-transaction-format https://blog.csdn.net/rejames/article/details/82885483 合约币https://hk.saowen.com/a/96d9c72062eed314bab4a1353d6de0f0cd492909fd8704c1f0eb2e674c8d670d https://hk.saowen.com/a/a3c33a6d50f274e9e0600a996442942194a681a6eeaf8962c1a04870ac96c320 ￼]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>对接币种钱包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grpc生成php代码(composer)]]></title>
    <url>%2F%2Fnote%2Fgrpc-generates-php-code-composer.html</url>
    <content type="text"><![CDATA[解决朋友不会编译问题写的备注 先去下载源码包https://github.com/protocolbuffers/protobuf/releases 解压后进入目录里面运行 12./configure --prefix=/usr/local/protobufmake &amp;&amp; make install 获取.proto的文件放到指定目录 在指定文件目录执行: 1/usr/local/protoc/bin/protoc --php_out=. zpt.proto 文档:https://developers.google.com/protocol-buffers/docs/reference/php-generated参考:https://my.oschina.net/laixhe/blog/1476644https://www.cnblogs.com/chunguang/p/5618588.htmlhttps://github.com/protocolbuffers/protobuf/tree/master/phphttps://developers.google.com/protocol-buffers/docs/downloads]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php 数据转json 中文转码问题]]></title>
    <url>%2F%2Fnote%2Fphp-data-to-json-chinese-transcoding-problem.html</url>
    <content type="text"><![CDATA[我们知道, 用PHP的json_encode来处理中文的时候, 中文都会被编码, 变成不可读的, 类似”\u***”的格式, 还会在一定程度上增加传输的数据量. &lt;?php echo json_encode(&quot;中文&quot;); //&quot;\u4e2d\u6587&quot;这就让我们这些在天朝做开发的同学, 很是头疼, 有的时候还不得不自己写json_encode. 而在PHP5.4, 这个问题终于得以解决, Json新增了一个选项: JSON_UNESCAPED_UNICODE, 故名思议, 就是说, Json不要编码Unicode. 看下面的例子: &lt;?php echo json_encode(&quot;中文&quot;, JSON_UNESCAPED_UNICODE); //&quot;中文&quot;怎么样, 是不是让大家很开心的改动? 呵呵, 当然, Json在5.4还加入了: JSON_BIGINT_AS_STRING, JSON_PRETTY_PRINT, JSON_UNESCAPED_SLASHES等选项, 如果有兴趣, 大家可以参看: json_encode 不过, 还是要提醒下: PHP 5.4还处于开发阶段, 在最终release之前, 任何新特性都可能被调整或者更改. 如果大家有任何建议, 也欢迎反馈, 帮助我们使得PHP变得更好. 本文转载文章 http://www.laruence.com/2011/10/10/2239.html]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>解决问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php 修改数组配置文件]]></title>
    <url>%2F%2Fnote%2Fphp-modify-array-configuration-file.html</url>
    <content type="text"><![CDATA[Thinkphp 12345678910111213141516171819/** * 刷新配置文件 */ protected function refreshFile() &#123; $config = []; foreach ($this-&gt;model-&gt;all() as $k =&gt; $v) &#123; $value = $v-&gt;toArray(); if (in_array($value['type'], ['selects', 'checkbox', 'images', 'files'])) &#123; $value['value'] = explode(',', $value['value']); &#125; if ($value['type'] == 'array') &#123; $value['value'] = (array)json_decode($value['value'], TRUE); &#125; $config[$value['name']] = $value['value']; &#125; file_put_contents(APP_PATH . 'extra' . DS . 'site.php', '&lt;?php' . "\n\nreturn " . var_export($config, true) . ";"); &#125; 其中 var_export函数是重点 函数官方文档传送门]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>解决问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单元测试文档学习笔记]]></title>
    <url>%2F%2Fnote%2Funit-test-document-study-notes.html</url>
    <content type="text"><![CDATA[注意事项: 编写单元测试,方法块注释不随意填写, 防止出现使用单元测试提供的注释语法无法使用 注释依赖(测试中的流程控制) 当某个测试所依赖的测试 失败时，PHPUnit 会跳过这个测试。 例如:测试a 需要 测试b获取的值 来进行测试a的测试;可以用注释依赖进行值传递 如果测试同时从 @dataProvider 方法和一个或多个 @depends 测试接收数据，那么来自于数据供给器的参数将先于来自所依赖的测试的。来自于所依赖的测试的参数对于每个数据集都是一样的。 如果一个测试依赖于另外一个使用了数据供给器的测试，仅当被依赖的测试至少能在一组数据上成功时，依赖于它的测试才会运行。使用了数据供给器的测试，其运行结果是无法注入到依赖于此测试的其他测试中的。 详细使用参考: 手册 数据供给器(自动迭代) 测试a 需要多种数据进行测试, 用数据供给器后,会自动迭代测试数据供给器提供的数据进行测试. 测试方法可以接受任意参数。这些参数由数据供给器方法（在 writing-tests-for-phpunit.data-providers.examples.DataTest.php中，是 ``additionProvider() 方法）提供。用 @dataProvider 标注来指定使用哪个数据供给器方法。 数据供给器方法必须声明为 public，其返回值要么是一个数组，其每个元素也是数组；要么是一个实现了 Iterator 接口的对象，在对它进行迭代时每步产生一个数组。每个数组都是测试数据集的一部分，将以它的内容作为参数来调用测试方法。 Example 2.5 使用返回数组的数组的数据供给器 123456789101112131415161718192021222324&lt;?phpuse PHPUnit\Framework\TestCase; class DataTest extends TestCase&#123; /** * @dataProvider additionProvider */ public function testAdd($a, $b, $expected) &#123; $this-&gt;assertEquals($expected, $a + $b); &#125; public function additionProvider() &#123; return [ [0, 0, 0], [0, 1, 1], [1, 0, 1], [1, 1, 3] ]; &#125;&#125;?&gt; 详细使用参考: 手册 测试出现异常:标注来测试被测代码中是否抛出了异常。 php原生异常 使用PHPUnit\Framework\Error 来注释 PHPUnit\Framework\Error\Notice 和 PHPUnit\Framework\Error\Warning 分别代表 PHP 通知与 PHP 警告。 如果测试依靠会触发错误的 PHP 函数，例如 fopen ，有时候在测试中使用错误抑制符会很有用。通过抑制住错误通知，就能对返回值进行检查，否则错误通知将会导致抛出 PHPUnit\Framework\Error\Notice。 对异常进行测试是越明确越好的。对太笼统的类进行测试有可能导致不良副作用。因此，不再允许用 @expectedException 或 setExpectedException() 对 Exception 类进行测试。 测试的功能或代码, 编写的测试运行后断言肯定会抛出异常,可以用@expectException指定抛出的异常类型;如果抛出异常类型同注释异常类型一致,结果为测试成功; @expectedExceptionCode (异常错误码)、@expectedExceptionMessage (异常信息)和 @expectedExceptionMessageRegExp (异常信息正则匹配) 详细使用参考: 手册 对输出进行测试(echo等)如echo, print. 单元测试使用输出缓冲区控制方式获取此内容 详见手册 方法:手册 手册 phpunit可生成日志(搭配Xdebug)文档 基镜(测试基础环境)在执行测试时,有时需要预先搭建测试环境.类似于php的魔术方法行为; 手册 测试替身 桩件 在桩件中,创建测试所需要的对象,所需要的对象可能依赖或者创建复杂使用难度高 有时候对被测系统(SUT)进行测试是很困难的，因为它依赖于其他无法在测试环境中使用的组件。这有可能是因为这些组件不可用，它们不会返回测试所需要的结果，或者执行它们会有不良副作用。在其他情况下，我们的测试策略要求对被测系统的内部行为有更多控制或更多可见性。 使用桩件可以替换掉被测试系统所依赖的实际组件;返回配置好返回值的测试替身(桩件)的方法称为上桩; 可以固定简单返回值,也可以使用变量实现更复杂的上桩willReturn($value) or will($this-&gt;returnValue($value)) 返回对桩件对象的引用will($this-&gt;returnSelf()); 不同参数对应的不同返回值方式上桩returnValueMap(array $map); 让上桩方法返回回调函数或方法的结果returnCallback(); 直接给出期望返回值的列表will($this-&gt;onConsecutiveCalls(2, 3, 5, 7));调用顺序返回 抛出异常will($this-&gt;throwException(new Exception)); 仿件对象 使用仿件对象，主要的功能是验证预期的行为，作为观察点来核实被测试系统在测试中的间接输出。 方法的执行次数expects($this-&gt;once())-&gt;method(&#39;update&#39;) 传入方法的参数with($this-&gt;equalTo(&#39;something&#39;)); 对特质(Trait)与抽象类进行模仿 对 Web 服务(Web Services)进行上桩或模仿 对文件系统进行模仿 12345678910public function testMockBuy()&#123; $appleMock = $this-&gt;getMockBuilder(Apple::class) -&gt;setMethods(['getPrice', 'buy']) -&gt;getMock(); //建立预期情况，buy方法会被调用一次 $appleMock-&gt;expects($this-&gt;once()) -&gt;method('buy'); $this-&gt;custom-&gt;buy($appleMock, 10);&#125; 文档地址]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>phpunit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpstorm珍藏常用快捷键]]></title>
    <url>%2F%2Fnote%2Fphpstorm-collection-common-shortcuts.html</url>
    <content type="text"><![CDATA[设置项 自动定位 (定位编辑文件所在的位置) Project面板，工具图标按钮（齿轮形状），弹出的菜单中选择 Autoscroll from Source 编辑文件时，左侧文件夹聚焦到该文件 手动定位-快捷键 在编辑的所选文件按ALT+F1, 然后选择PROJECT VIEW(新版下一级 Project) PHP手册 Preferences -&gt; Tools-&gt;External Tools Parameters参数 http://php.net/manual/zh/function.$SelectedText$.php 注意： SelectedText 启动的时候不打开工程文件 Preferences-&gt;Appearance &amp; Behavior -&gt;System Settings 去掉 Reopen last project on startup.up. 使用功能 语法分析 Inspect Code 语法分析非常有用 右击 文件夹或文件，在菜单中选择 Inspect Code，会弹出 让你选择是指定目录文件或者还是整个项目 常用代码片段 CTRL(cmd) + j能够快捷的输入常用的代码片段，类似vim的 snipMate，可以自定义代码片段 代码格式化 ctrl+alt+l代码格式化 Setting: Live Templates代码片断 https://laracasts.com/series/how-to-be-awesome-in-phpstorm 光标跳转 移动光标到当前所在代码的花括号开始位置 Ctrl + [ Option+Command+[ 移动光标到当前所在代码的花括号结束位置 Ctrl + ] Option+Command+] 行处理 删除光标所在行 或 删除选中的行. Ctrl + Y, Command+delete 递进式选择代码块,可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围. Ctrl + W , Option+↑ 在当前文件跳转到指定行处(代码报错跳转) Ctrl + G Command+L ⌘+L 类处理 显示当前类的层次结构(继承或实现接口层次结构) Ctrl + H Control + H 选择可重写的方法(接口方法) Ctrl + O Control + O 选择可继承的方法 Ctrl + I Control + I 根据输入的 类名 查找类文件 Ctrl + N Command+O ⌘+O 进入光标所在的方法/变量的接口或是定义出 (预测返回值,详细类型) Ctrl + B或 Ctrl + 左键单击 Command + B 或 Command + 左键单击 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选 Ctrl + F12 Command+F12 查找//@todo标签 Alt + 6 Command+6 显示类中的方法(左下角显示) Alt + 7 Command+7 显示类中的方法 Alt + 8 Command+8 代码自动生成， 如生成对象的 set / get 方法， 构造函数，toString() 等 (get成员属性) Alt + Insert Control+Enter 或 Command+N 代码块 智能分隔行(左侧小灯泡实现) Ctrl + Enter Option+Enter 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的(左侧小灯泡实现)结果也不同 Alt + Enter Option+Enter 展开代码 Ctrl + + 折叠代码 Ctrl + - 选中文本， 逐个往下查找相同文本，并高亮显示 Alt + F3 Command+F 退回到上一个操作的地方 （必备） Ctrl + Alt + 左方向键 Option+Command+← 前进到上一个操作的地方 （必备） Ctrl + Alt + 右方向键 Option+Command+→ 注释 设置中搜索show quick document 鼠标移过将会显示定义时的注释 Ctrl(cmd) + /，单行注释 Ctrl(cmd) + Shift + /，多行注释,块注释 /** + Enter，自动生成注释 工作区 刷新工作区目录 当有新文件,idea并没有显示就需要手动刷新 在Save All旁边的按钮Synchronize按钮(Mac)option+command+Y (win)可能是ctrol+alt+Y 本文内容部分来源:https://blog.csdn.net/fenglailea/article/details/53350080?utm_source=copy]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>利器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端cdn失效修复]]></title>
    <url>%2F%2Fnote%2Ffrontend-cdn-failure-repair.html</url>
    <content type="text"><![CDATA[前端cdn失效修复 博客出现访问卡死现象,排查一下发现https://cdn.bootcss.com/的访问卡住,导致页面白屏等待资源加载 将https://cdn.bootcss.com/替换为https://cdnjs.cloudflare.com/ajax/libs/]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>容易疏忽的问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql查询设置大小写敏感以及性能(explain)对比]]></title>
    <url>%2F%2Fnote%2Fmysql-query-sets-case-sensitivity-and-performance-explain-comparison.html</url>
    <content type="text"><![CDATA[受到 此文 某些似懂非懂话语影响而折腾的笔记 解决方法: 查询时加上binaryexplain 分析 sql语句其中type有变动(sk已加上索引) type值解析 而不加binary 不区分大小写时 查询时强制二进制对比，尤其不好，这会让你代码中多出很多判断，且还有可能被绕过。至于直接使用二进制字段，mysql不会将它当成字符来处理，我觉得也可能存在问题。 字段建立时指定字符类型点我查看 建立时的字符类型 使用utf8_bin select * from api_key where sk = &#39;Gsxg583i+JhD4nHFCroeLKlMpUAI0XV9Rzjf6YqO_1Svy7QZkmw2PB&#39; Select 语句可以区分大小写 执行效率: explain select * from api_key where sk = &#39;GSxg583i+JhD4nHFCroeLKlMpUAI0XV9Rzjf6YqO_1Svy7QZkmw2PB&#39; 使用BINARY `select * from api_key where sk = &apos;Gsxg583i+JhD4nHFCroeLKlMpUAI0XV9Rzjf6YqO_1Svy7QZkmw2PB&apos;` Select 语句可以区分大小写 执行效率: `explain select * from api_key where sk = &apos;GSxg583i+JhD4nHFCroeLKlMpUAI0XV9Rzjf6YqO_1Svy7QZkmw2PB&apos;` 数据库创建时修改方式1方式2 laravel 数据库迁移解决方案12345678910public function up()&#123; Schema::create(&apos;api_key&apos;, function (Blueprint $table) &#123; //一堆建表语句 &#125;); //创建表成功后添加大小写敏感 DB::statement(&quot;alter table api_key modify column ak varchar(255) BINARY DEFAULT &apos;&apos; NOT NULL COMMENT &apos;as&apos;&quot;); DB::statement(&quot;alter table api_key modify column sk varchar(255) BINARY DEFAULT &apos;&apos; NOT NULL COMMENT &apos;as&apos;&quot;);&#125; 最终得出以上更改其实本质上也是把collatioin(校对)模式改成二进制校对，实现大小写敏感。 索引长度在判断大小写时会增加1,但是type会变成ref; 附给细心同学的懒人链接:key_len 参考资料:https://www.cnblogs.com/sonofelice/p/6432986.htmlhttp://cevin.net/archives/让mysql查询区分大小写.htmlhttps://blog.csdn.net/dennis211/article/details/78170079https://www.cnblogs.com/yuyue2014/p/3700531.htmlhttps://www.cnblogs.com/clphp/p/5403215.html]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>容易疏忽的问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php二维数组数据指定键唯一合并]]></title>
    <url>%2F%2Ftechnology-php%2Fphp-twodimensional-array-data-specified-key-unique-merge.html</url>
    <content type="text"><![CDATA[例子: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546array:11 [ 0 =&gt; array:2 [ "publicadtype" =&gt; "h5-zmiti" "num" =&gt; 16 ] 1 =&gt; array:2 [ "publicadtype" =&gt; "图片-zmiti" "num" =&gt; 88 ] 2 =&gt; array:2 [ "publicadtype" =&gt; "视频-zmiti" "num" =&gt; 13 ] 3 =&gt; array:2 [ "publicadtype" =&gt; "音频-zmiti" "num" =&gt; 30 ] 4 =&gt; array:2 [ "publicadtype" =&gt; "视频-zmiti" "notaudit" =&gt; 4 ] 5 =&gt; array:2 [ "publicadtype" =&gt; "h5-zmiti" "trial" =&gt; 16 ] 6 =&gt; array:2 [ "publicadtype" =&gt; "图片-zmiti" "trial" =&gt; 88 ] 7 =&gt; array:2 [ "publicadtype" =&gt; "视频-zmiti" "trial" =&gt; 8 ] 8 =&gt; array:2 [ "publicadtype" =&gt; "音频-zmiti" "trial" =&gt; 27 ] 9 =&gt; array:2 [ "publicadtype" =&gt; "视频-zmiti" "initialfailure" =&gt; 1 ] 10 =&gt; array:2 [ "publicadtype" =&gt; "音频-zmiti" "thefinal" =&gt; 3 ]] 将此数组变为: 12345678910111213141516171819202122232425array:4 [ 0 =&gt; array:3 [ "publicadtype" =&gt; "h5-zmiti" "num" =&gt; 16 "trial" =&gt; 16 ] 1 =&gt; array:3 [ "publicadtype" =&gt; "图片-zmiti" "num" =&gt; 88 "trial" =&gt; 88 ] 2 =&gt; array:5 [ "publicadtype" =&gt; "视频-zmiti" "num" =&gt; 13 "notaudit" =&gt; 4 "trial" =&gt; 8 "initialfailure" =&gt; 1 ] 3 =&gt; &amp; array:4 [ "publicadtype" =&gt; "音频-zmiti" "num" =&gt; 30 "trial" =&gt; 27 "thefinal" =&gt; 3 ]] 可用代码: 123456789101112131415$json = '[&#123;"publicadtype":"h5-zmiti","num":16&#125;,&#123;"publicadtype":"\u56fe\u7247-zmiti","num":88&#125;,&#123;"publicadtype":"\u89c6\u9891-zmiti","num":13&#125;,&#123;"publicadtype":"\u97f3\u9891-zmiti","num":30&#125;,&#123;"publicadtype":"\u89c6\u9891-zmiti","notaudit":4&#125;,&#123;"publicadtype":"h5-zmiti","trial":16&#125;,&#123;"publicadtype":"\u56fe\u7247-zmiti","trial":88&#125;,&#123;"publicadtype":"\u89c6\u9891-zmiti","trial":8&#125;,&#123;"publicadtype":"\u97f3\u9891-zmiti","trial":27&#125;,&#123;"publicadtype":"\u89c6\u9891-zmiti","initialfailure":1&#125;,&#123;"publicadtype":"\u97f3\u9891-zmiti","thefinal":3&#125;]';$data = json_decode($json, true);foreach ($data as $nk =&gt; &amp;$nv) &#123; foreach ($data as $nnk =&gt; $nnv) &#123; if ($nk !== $nnk) &#123; if (in_array($nv['publicadtype'], $nnv)) &#123; $nv = array_merge($nv, $nnv); if ($nnk !== $nk) &#123; unset($data[$nnk]); &#125; &#125; &#125; &#125;&#125; ps:此代码有一个重复赋值找出修改方法吧 数组复杂处理常见的引用符号,加上后有些重复处理和赋值会直接操作原有数组.]]></content>
      <categories>
        <category>PHP技术栈</category>
      </categories>
      <tags>
        <tag>解决问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码习惯-2019.06.03]]></title>
    <url>%2F%2Fnote%2Fcoding-habit-20190603.html</url>
    <content type="text"><![CDATA[本文档长期不定时更新 在使用get()或者select() 查询列表时,要么分页,要么limit限制最大长度 在使用return 时尽量只有一个return 方便查阅; 在编写类时,注意单一职责; 变量尽量在有必要提前存在时才声明 php是弱类型语言,对数据记得做类型校验 对方法参数做类型约束 数据库状态或数字代表含义的, 放在配置文件然后调取语义化配置使用,方便查阅 不使用is_系列函数,使用全等替换 减少使用= = 而去使用=== 案例 在c中i++只需要一条cpu指令, 一直以为$i++的效率很高, 但是我看到的框架(比如tp)都没用使用$i++, 而是使用$i += 1, 在php中$i++需要4条opcodes 编写或调用缓存时 注意:命中 (Hit) - 一个缓存的命中，指的是当调用类库使用「键」在请求一个缓存项的时候，在缓存池里能找到对应的缓存项，并且此缓存项还未过期，并且此数据不会因为任何原因出现错误。调用类库 应该 确保先验证下 isHit() 有命中后才调用 get() 获取数据。 参考 前后端分离返回数据的参数键命名分隔时,尽量使用下划线分隔 在laravel模型通过属性获取模型关联数据数据如果这个字段有可能不存在的 使用isset判断 或使用 ?? ‘’ 编写权限或者状态时预留方法 返回可用账户的where组合 按照单一职责原则，一个类只应该关心自己的逻辑，当出现问题的时候，如果不是当前类该处理的，我们就应该抛出而不是消化。 业务异常与运行时异常要区分开 一个类只干自己相关的事情，比如通知类不要去关心 SMTP 如何构造。 一个方法只干一件事儿，如何定义呢？当你给方法起名的时候纠结了，那你的方法设计得就有问题了，getUserById，getUsers 这些肯定就是只干了一件事儿。 命名要见名知义，动名词格式命名。少用 info，data 这类无意义词，比如 getUserInfo 完全可以叫 getUser。getOrdersData，getOrdersList 也完全可以写为 getOrders。 一个方法尽量不要超过 30 行；]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>编码习惯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端翻译国际化]]></title>
    <url>%2F%2Ftechnology-web%2Ffrontend-translation-internationalization.html</url>
    <content type="text"><![CDATA[标签（空格分隔）： 网站国际化支持 在网站中加入: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;script&gt; var langPackage = &#123; &quot;主题&quot;: &quot;Title&quot;, &quot;下一页&quot;: &quot;NextPage&quot;, &quot;末页&quot;: &quot;LastPage&quot;, &quot;首页&quot;: &quot; FirstPage &quot;, &quot;上一页&quot;: &quot; PreviousPage &quot;, &quot;待办工作&quot;: &quot;MyTasks&quot;, &quot;中&quot;: &quot;Middle&quot;, &quot;每页&quot;: &quot; EachPage &quot;, &quot;条&quot;: &quot; Record &quot;, &quot;共&quot;: &quot; Total &quot;, &quot;页&quot;: &quot; Page &quot;, &quot;第&quot;: &quot; Current &quot;, &quot;工作主题&quot;: &quot; ProcTitle&quot; &#125;; /* 主调函数 在 Jquery的 .read方法里调用 ReplaceChildChs($(document)); 或者页面的最后调用 ReplaceChildChs($(document)); */ function ReplaceChildChs(nodeObj) &#123; // if($(&quot;#hdfUseLang&quot;).val()==&quot;CN&quot;)return; if (nodeObj.children().length &gt; 0) &#123; nodeObj.children().each(function() &#123; ReplaceChildChs($(this)); // if ($(this)[0].nodeName.toUpperCase() == &quot;TD&quot;)&#123; FindChsAndReplaceIt($(this)); // &#125; &#125;); &#125; else &#123; FindChsAndReplaceIt(nodeObj); &#125; &#125; // 直接替换html 的一种设想，但总是报错 function JustReplaceChsDom(nodeObj) &#123; var pat = new RegExp(&quot;[\u4e00-\u9fa5]+&quot;, &quot;g&quot;); // 匹配中文的正则表达式 var str = $(nodeObj).html(); while ((arr = pat.exec(str)) != null) &#123; if (langPackage[arr[0]]) &#123; str = str.replace(arr[0], langPackage[arr[0]]); &#125; &#125; $(nodeObj).html(str); &#125; function FindChsAndReplaceIt(nodeObj) &#123; var pat = new RegExp(&quot;[\u4e00-\u9fa5]+&quot;, &quot;g&quot;); if ((nodeObj.text() || nodeObj.val() || nodeObj.attr(&quot;title&quot;)) &amp;&amp; (pat.exec(nodeObj.text()) || pat.exec(nodeObj.val()) || pat.exec(nodeObj.attr(&quot;title&quot;)))) &#123; var str = &quot;&quot; if (nodeObj.text()) &#123; str = nodeObj.text(); ReplaceValue(str, nodeObj, &quot;text&quot;); &#125; if (nodeObj.val()) &#123; str = nodeObj.val(); ReplaceValue(str, nodeObj, &quot;val&quot;); &#125; if (nodeObj.attr(&quot;title&quot;)) &#123; str = nodeObj.attr(&quot;title&quot;); ReplaceValue(str, nodeObj, &quot;title&quot;); &#125; &#125; &#125; function ReplaceValue(str, nodeObj, attrType) &#123; var arr; var pat = new RegExp(&quot;[\u4e00-\u9fa5]+&quot;, &quot;g&quot;); while ((arr = pat.exec(str)) != null) &#123; if (langPackage[arr[0]]) &#123; str = str.replace(arr[0], langPackage[arr[0]]); if (attrType == &quot;text&quot;) &#123; nodeObj.text(str); &#125; else if (attrType == &quot;val&quot;) &#123; nodeObj.val(str); &#125; else if (attrType == &quot;title&quot;) &#123; nodeObj.attr(&quot;title&quot;, str); &#125; &#125; &#125; &#125; ReplaceChildChs($(document));&lt;/script&gt; 上面数组进行单词替换;文章啥的最好还是有多语言的支持 translate翻译方式 需要翻墙123456789101112131415161718&lt;div id=&quot;google_translate_element&quot;&gt;&lt;/div&gt;&lt;script&gt; function googleTranslateElementInit() &#123; new google.translate.TranslateElement(&#123; pageLanguage: &apos;zh-CN&apos;, layout: google.translate.TranslateElement.InlineLayout.SIMPLE &#125;, &apos;google_translate_element&apos;); &#125;&lt;/script&gt;&lt;script src=&quot;//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit&quot;&gt;&lt;/script&gt;&lt;!-- Begin TranslateThis Button --&gt;&lt;div id=&quot;translate-this&quot;&gt;&lt;a href=&quot;http://translateth.is/&quot; class=&quot;translate-this-button&quot;&gt;Translate&lt;/a&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.google.com/jsapi&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://x.translateth.is/translate-this.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; TranslateThis();&lt;/script&gt;&lt;!-- End TranslateThis Button --&gt;]]></content>
      <categories>
        <category>前端技术栈</category>
      </categories>
      <tags>
        <tag>i18n</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rtmp流媒体 nginx服务端搭建]]></title>
    <url>%2F%2Fmo-ren-fen-lei%2Frtmp-streaming-nginx-server-build.html</url>
    <content type="text"><![CDATA[rtmp流媒体 nginx服务端搭建标签（空格分隔）： 直播 mkdir nginx 切换到nginx目录，下载压缩包并解压到当前工作目录： wget http://nginx.org/download/nginx-1.12.1.tar.gz tar -zxvf nginx-1.12.1.tar.gz 安装依赖的的库： sudo apt-get install libssl-dev libpcre3-dev zlib1g-dev 下载rtmp模块，生成目录nginx-rtmp-module： git clone https://github.com/arut/nginx-rtmp-module.git 切换到nginx-1.12.1目录，执行（如果想build调试版本的话，要添加–with-debug）： ./configure –add-module=/home/sunrayme/nginx/nginx-rtmp-modulemake sudo make install 运行nginx： sudo /usr/local/nginx/sbin/nginx ffmpeg -f dshow -i video=”BisonCam, NB Pro”:audio=”麦克风 (Realtek High Definition Audio)” -vcodec libx264 -acodec copy -preset:v ultrafast -tune:v zerolatency -f flv “rtmp://p855c26b6.live.126.net/live/685f6451704349a8bed4489f170d4084?wsSecret=1e0357b0ce7e101ac0613396148ae2b4&amp;wsTime=1523430887” netstat -ntlp 查看端口占用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;rtmp &#123; server &#123; listen 1935; #监听的端口 chunk_size 4000; application myapp &#123; live on; &#125; application hls &#123; #rtmp推流请求路径 live on; hls on; hls_path /tmp/hls; hls_fragment 3s; &#125; &#125; &#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 8080; #charset koi8-r; #access_log logs/host.access.log main; location /state &#123; rtmp_stat all; rtmp_stat_stylesheet stat.xsl; &#125; location /stat.xsl &#123; root /vagrant_date/nginx-rtmp-module-master; &#125; &#125; server &#123; listen 81; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; #加入hls支持 location /hls &#123; types &#123; application/vnd.apple.mpegurl m3u8; #或 application/x-mpegURL video/mp2t ts; &#125; alias /tmp/hls; #视频流文件目录(自己创建) expires -1; add_header Cache-Control no-cache; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 配置文件验证 /usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf ffmpeg -f dshow -i video=”BisonCam, NB Pro”:audio=”麦克风 (Realtek High Definition Audio)” -vcodec libx264 -acodec copy -preset:v ultrafast -tune:v zerolatency -f flv “rtmp://192.168.1.113/live live=1” rtmp://192.168.1.113:1935/hls/testrtmp://192.168.1.113:1935/myapp/testhls 加上mp4flv播放和清缓存 ./configure –with-http_ssl_module –add-module=../nginx-rtmp-module –with-http_v2_module –with-http_ssl_module –with-http_sub_module –with-http_stub_status_module –with-http_gzip_static_module –with-pcre 1./configure --prefix=/usr/local/nginx/ --add-module=../nginx-rtmp-module --add-module=../ngx_cache_purge-master --with-http_stub_status_module --with-http_ssl_module --with-http_sub_module --with-http_gzip_static_module --with-http_mp4_module --with-http_flv_module yum -y install pcre-devel openssl openssl-devel 有时候，我们需要单独安装nginx，来处理大量的下载请求。单独在Centos5安装nginx遇到的rewrite和HTTP cache错误解决办法： wget http://nginx.org/download/nginx-0.8.33.tar.gztar -zxvf nginx-0.8.33.tar.gzcd nginx-0.8.33./configure –prefix=/usr/local/nginx 安装Nginx时报错 ./configure: error: the HTTP rewrite module requires the PCRE library. 安装pcre-devel解决问题yum -y install pcre-devel 错误提示：./configure: error: the HTTP cache module requires md5 functionsfrom OpenSSL library. You can either disable the module by using–without-http-cache option, or install the OpenSSL library into the system,or build the OpenSSL library statically from the source with nginx by using–with-http_ssl_module –with-openssl= options. 解决办法： yum -y install openssl openssl-devel 总结： yum -y install pcre-devel openssl openssl-devel ./configure –prefix=/usr/local/nginx make make install 昌书电脑安装记录 nginx path prefix: “/usr/local/nginx/“ nginx binary file: “/usr/local/nginx//sbin/nginx” nginx modules path: “/usr/local/nginx//modules” nginx configuration prefix: “/usr/local/nginx//conf” nginx configuration file: “/usr/local/nginx//conf/nginx.conf” nginx pid file: “/usr/local/nginx//logs/nginx.pid” nginx error log file: “/usr/local/nginx//logs/error.log” nginx http access log file: “/usr/local/nginx//logs/access.log” nginx http client request body temporary files: “client_body_temp” nginx http proxy temporary files: “proxy_temp” nginx http fastcgi temporary files: “fastcgi_temp” nginx http uwsgi temporary files: “uwsgi_temp” nginx http scgi temporary files: “scgi_temp” 编译时出现 set but not used [-Werror=unused-but-set-variable] 问题的解决办法： 找到对应目录(nginx中)中的Makefile文件，找到 -Werror 字段，去掉-Werror，重新编译，则问题解决 rtmp://p855c26b6.live.126.net/live/685f6451704349a8bed4489f170d4084?wsSecret=aec4eda8a73a12c2dd525319608bf533&amp;wsTime=1523520333 rtmp://192.168.1.119:1935/myapp/test rtmp://192.168.1.119:1935/myapp/test rtmp://192.168.1.119:1935/hls/test http://111.231.138.185:81/hls/test #user nobody;worker_processes 2; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024;} http { include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 8080; #charset koi8-r; #access_log logs/host.access.log main; location /state { rtmp_stat all; rtmp_stat_stylesheet stat.xsl; } location /stat.xsl { root /vagrant_date/nginx-rtmp-module-master; } } server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; #加入hls支持 location /hls { types { application/vnd.apple.mpegurl m3u8; #或 application/x-mpegURL video/mp2t ts; } alias /tmp/hls; #视频流文件目录(自己创建) expires -1; add_header Cache-Control no-cache; } }} rtmp_auto_push on; #因为Nginx可能开启多个子进程，这个选项表示推流时，媒体流会发布到多个子进程 rtmp { server { listen 1935; #监听的端口 chunk_size 4000; application myapp { live on; } application hls { #rtmp推流请求路径 live on; hls on; hls_path /tmp/hls; hls_fragment 3s; #每个视频切片的时长 hls_playlist_length 0s; #总共可以回看的事件，这里设置的是1分钟。 hls_continuous on; #连续模式。 hls_cleanup on; #对多余的切片进行删除。 hls_nested on; #嵌套模式。 } }}]]></content>
      <categories>
        <category>默认分类</category>
      </categories>
      <tags>
        <tag>rtmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地网络 远程访问 frp内网穿透]]></title>
    <url>%2F%2Fnote%2Flocal-network-remote-access-frp-intranet-penetration.html</url>
    <content type="text"><![CDATA[标签： 内网穿透 初衷在早前建站时,想过使用本地架设服务端,让远程访问到本地网站端口. 想法遇到的问题 在本地架设服务端,需要有一台可以作网站解析的电脑(并且长期在线); 需要有公网ip,按照国内运营商的尿性,以及自己的打探 因为公网ip资源紧缺,国内的网络基本属于 一群小弟(我们买的宽带) 希望看场子(访问广域网) 但是小弟必须去请求老大(宽带提供商),去分配给你一个公网ip 如果运营商客气一般能直接开(这篇文章对你没用了),如果不客气要么需要一系列手续,更或者直接说家用宽带没有公网ip; 解决思路 这些问题中第一个想想就感觉有些吃力,但是目前我使用的方案是从网上买个树莓派,在家里一直挂着(树莓派3 5v2A=10w，一天24小时=0.24度电，一个月4元,加上路由器的 4 元一个月大概8元[能接受]) 公网ip这个可以通过自己的服务器有一个公网ip解决 (撸学生云大概是50多半年[最多]),然后使用本篇文章提供的内网穿透教程,就可以好好玩了; 内网穿透教程拉轮子我从网上看了一些老的教程,跟新的版本使用并没有多少出入,所以本文可以放心实验; 下载frp客户端和服务端:传送门(32位为386,64位为amd64) 准备一个客户端,一个服务端(具备公网ip的服务器或主机); 使用轮子下载 下载windows版本,最下边(32位为386,64位为amd64) 服务端也下载安装对应系统的版本 我这次使用的是linux的服务端,不同系统配置都差不多,继续看下去; 目录解析windows下载后文件夹是这样的 Linux下载解压(网上有教程)后是这样的是不是差不多; 配置也差不多; 可以单独这样 frp 后面加上 s 的是服务端, c 是客户端 如果有公网IP 将frps和frps.ini添加到您的服务器。 将frpc和frpc.ini放到您局域网中的服务器上。 案例通过公网ip的7000端口,访问您的计算机的80端口 配置服务端: 修改frps.ini： 123[common]bind_port = 7000 #绑定7000vhost_http_port = 8080 # 绑定8080 为http服务端口 开启服务端: linux: 1./frps -c ./frps.ini windows 打开cmd(右键左下角windows图标,点击运行输入cmd确定)然后切换到程序所在目录; 你可能碰到的一些命令: cd ..切换到上级目录如C:\Users\qiaoanqiao使用该命令会到C:\Users dir 显示当前目录中的文件夹和文件,后面跟上目录显示这个目录中的文件夹或文件 E: 盘符号加上一个冒号,切换盘符. 经过一系列命令,我可以假设你到了这个程序的解压后目录,然后也是执行 1./frps -c ./frps.ini 配置客户端: 修改frpc.ini，server_addr是你frps(服务端)公网IP： 12345678[common]server_addr = x.x.x.x #指定服务端的公网ipserver_port = 7000 #指定服务端的内网穿透软件监听端口[web] type = http #类型 http,还有tcp udplocal_port = 80 #本地端口custom_domains = www.yourdomain.com #访问过来的域名 客户端打开: 1./frpc -c ./frpc.ini 然后 域名www.yourdomain.com将IP x.x.x.x或CNAME记录的记录值解析到您的域名。浏览器访问 http://www.yourdomain.com:8080 还有更多实例请参考:传送门]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vagrant使用记录]]></title>
    <url>%2F%2Fnote%2Fvagrant-usage-record.html</url>
    <content type="text"><![CDATA[标签（空格分隔）： vagrant 看本文首先你要对vagrant有一定了解 传送门 从网上搜索国内镜像源,他们说官方有cdn那就从官方搜索下载了 Vagrant 就是使用 Ruby 写成的, 所以在这里的配置文件也需要满足 Ruby 语法。 config.vm.box = “ubuntu/trusty64”可以看到，这两行就是我们在vagrant init中后面所指定的参数。由此可以看出，vagrant init只是帮我们生成了配置文件而已，换句话说，如果我们写好了Vagrantfile，就不需要vagrant init，只需将准备好的配置文件放入到所需目录中，然后直接执行vagrant up即可。 还有很多注释掉的配置，那些都是一些常用的配置，包括网卡设置、IP地址、绑定目录，甚至可以指定内存大小、CPU个数、是否启动界面等等。如果需要，可以根据注释文本进行配置。 下面列出一些常用的配置： config.vm.hostname：配置虚拟机主机名 config.vm.network：这是配置虚拟机网络，由于比较复杂，我们其后单独讨论 config.vm.synced_folder：除了默认的目录绑定外，还可以手动指定绑定 config.ssh.username：默认的用户是vagrant，从官方下载的box往往使用的是这个用户名。如果是自定制的box，所使用的用户名可能会有所不同，通过这个配置设定所用的用户名。 config.vm.provision：我们可以通过这个配置在虚拟机第一次启动的时候进行一些安装配置，后面我们将专门介绍。需要注意的是，Vagrantfile文件只会在第一次执行vagrant up时调用执行，其后如果不明确使用vagrant reload，则不会被强制重新加载。 config.vm.network”forwarded_port”,guest:80,host:8080这将让物理机的8080端口映射到虚拟机的80端口。因此，可以在物理机上直接访问虚拟机所建立的网站。这在虚拟机使用不是桥接的时候尤为重要，因为很多时候默认会禁止物理机通过网络直接访问虚拟机，通过端口映射可以依旧能够访问所需端口。 我们还可以通过config.vm.network来指定所在网络以及IP地址。一般来说，分为private_network还是public_network。 private_network： 私有网络位于私有网络的主机之间可以互相访问，但是外界无法访问私有网络的主机，对于某些虚拟机而言，连物理机都无法通过网络直接访问虚拟机，此时如果需要使用物理机访问虚拟机，就需要前面所提及的端口映射。例如： config.vm.network&quot;private_network&quot;,ip:&quot;192.168.33.10&quot;public_network：公有网络在绝大多数虚拟机上，这等同于桥接网络。如果虚拟机选择了桥接方式连接，也就是相当于虚拟机和物理机在网络上处于平等的位置，同样的接在了网卡所在的网络。因此从外界看来，会感觉这是两台独立的计算机。 配置方式和私有网络接近，只需将其中的private_network换成public_network。如要使用 DHCP： config.vm.network&quot;public_network&quot;如果物理机存在多块网卡，需要指定某一块作为桥接用，那么可以参考如下配置： config.vm.network&quot;public_network&quot;,:bridge=&gt;&apos;en1: Wi-Fi (AirPort)&apos;如果是在启动了虚拟机之后，需要重新加载配置，只需要执行： vagrant reload vagrant基本命令，根据操作的目的，可以对基本命令进行分类：1 操作镜像box package2 操作虚拟机connect destroy halt init powershell provision rdp reload resume share snapshot ssh suspend up3 监控虚拟机global-status ssh-config port status4 其他help login plugin push version 1 操作镜像该命令有两个，用来管理本地镜像1.1 vagrant box1.1.1 添加镜像到本地仓库$ vagrant box add [box-name] [box镜像文件或镜像名] 1.1.2 移除本地镜像$ vagrant box remove [box-name] box多版本共存的情况如果box升级过，那么在box list中会出现两个同名，但版本不同的镜像。如：$ vagrant box list |grep coreoscoreos-alpha (virtualbox, 745.1.0)coreos-alpha (virtualbox, 928.0.0) 使用该镜像创建虚拟机的时候，默认会使用高版本的box。如果想使用低版本，需要修改Vagrantfile,指定box-version在config.vm.box=xxx下一行，如上面的例子中，在“config.vm.box = “coreos-alpha””后面增加一行配置信息：config.vm.box_version = “745.1.0” 同样，如果想删除一个box，如下操作会失败：$ vagrant box remove coreos-alphaYou requested to remove the box ‘coreos-alpha’ with provider‘virtualbox’. This box has multiple versions. You mustexplicitly specify which version you want to remove withthe --box-version flag or specify the --all flag to remove allversions. The available versions for this box are: 745.1.0 928.0.0 这时有两个选择： vagrant box remove coreos-alpha –all删除所有同名镜像 vagrant box remove coreos-alpha –box-version=745.1.0删除指定版本的镜像 1.1.3 升级镜像检查镜像是否有升级？$ cd ~/vm/ubuntu$ vagrant box outdatedChecking if box ‘ubuntu/trusty64’ is up to date…A newer version of the box ‘ubuntu/precise64’ is available! You currentlyhave version ‘20160122.0.0’. The latest is version ‘20160209.0.0’. Runvagrant box update to update. 中央仓库有新版更新了，手动更新box。更新的结果并不是替换旧版本，而是在本地仓库中增加了新版的box镜像。$ cd ~/vm/ubuntu$ vagrant box update==&gt; default: Checking for updates to ‘ubuntu/precise64’ default: Latest installed version: 20160120.0.0 default: Version constraints: default: Provider: virtualbox==&gt; default: Updating ‘ubuntu/precise64’ with provider ‘virtualbox’ from version==&gt; default: ‘20160120.0.0’ to ‘20160201.0.0’…==&gt; default: Loading metadata for box ‘https://atlas.hashicorp.com/ubuntu/precise64?access_token=cXR0wCgWXoRpMw.atlasv1.ydBAS4ev1YCWzSK4S1l6iVjssRbO5Q50a8YVnEPqoyYjcQVeaMdEsiQ8rz8tOcSHLuY&#39;==&gt; default: Adding box ‘ubuntu/precise64’ (v20160201.0.0) for provider: virtualbox default: Downloading: https://atlas.hashicorp.com/ubuntu/boxes/precise64/versions/20160201.0.0/providers/virtualbox.box==&gt; default: Successfully added box ‘ubuntu/precise64’ (v20160201.0.0) for ‘virtualbox’! $ vagrant box list | grep precise64ubuntu/precise64 (virtualbox, 20160120.0.0)ubuntu/precise64 (virtualbox, 20160201.0.0) 也可以检查本地仓库中的所有镜像是否有升级,使用 –global 开关，这时候不需要进入工作目录$ vagrant box outdated –global ‘ubuntu/trusty64’ is outdated! Current: 20160122.0.0. Latest: 20160209.0.0 ‘ubuntu/precise64’ (v20160201.0.0) is up to date ‘pollyduan/bento_oracle_xe’ wasn’t added from a catalog, no version information ‘phusion/ubuntu-14.04-amd64’ (v2014.04.30) is up to date ‘hashicorp/precise32’ (v1.0.0) is up to date ‘hashicorp/boot2docker’ (v1.7.8) is up to date ‘debian/jessie64’ wasn’t added from a catalog, no version information ‘coreos-alpha’ is outdated! Current: 928.0.0. Latest: 955.0.0 ‘centos7’ wasn’t added from a catalog, no version information ‘centos65’ wasn’t added from a catalog, no version information ‘centos64’ wasn’t added from a catalog, no version information ‘bento/ubuntu-14.04’ (v2.2.3) is up to date ‘bento/opensuse-13.2-x86_64’ (v2.2.1) is up to date ‘bento/freebsd-10.2’ (v2.2.3) is up to date ‘bento/fedora-22’ (v2.2.3) is up to date ‘bento/debian-8.2’ (v2.2.3) is up to date ‘bento/centos-7.2’ (v2.2.3) is up to date ‘bento/centos-6.7’ (v2.2.3) is up to date 不进入工作目录进行升级$ vagrant box update –box coreos-alphaChecking for updates to ‘coreos-alpha’Latest installed version: 928.0.0Version constraints: &gt; 928.0.0Provider: virtualboxUpdating ‘coreos-alpha’ with provider ‘virtualbox’ from version‘928.0.0’ to ‘955.0.0’…Loading metadata for box ‘http://alpha.release.core-os.net/amd64-usr/current/coreos_production_vagrant.json&#39;Adding box ‘coreos-alpha’ (v955.0.0) for provider: virtualboxDownloading: http://alpha.release.core-os.net/amd64-usr/955.0.0/coreos_production_vagrant.boxBox download is resuming from prior download progressProgress: 1% (Rate: 92912/s, Estimated time remaining: 0:38:09)… 1.2 打包镜像创建vm以后，我们自己根据需要安装软件，配置环境，都一切就绪了。如何分发给小伙伴使用呢？这里就要涌到package命令了，把镜像打包分发。$ ll ~/VirtualBox\ VMs/ |grep ubuntudrwx—— 6 pollyduan staff 204 2 2 11:18 ubuntu_default_1453944793418_7699先看一下我们的vm目录名，这里有个容易混淆的目录： Vagrantfile所在的目录——vagrant的工作目录 虚拟机文件所在的目录——virtualbox的工作目录这两个目录名不一定相同，如果在Vagrantfile中指定了vb.name，virtualbox工作目录就取这个名字；否则，命名为：vagrant工作目录_随机字符串。或者，也可以使用virtual box的管理工具来看vm的名称。 $ VBoxManage list vms|grep ubuntu“ubuntu_default_1453944793418_7699” {0362edc2-548b-400b-a55d-776b0a24cd8d} package命令要使用的是virtual box工作目录。 格式：vagrant package –base [virtualbox的工作目录] –output [保存的文件名，缺省为package.box] $ vagrant package –base ubuntu_default_1453944793418_7699 –output ubuntu_myproject_test.box==&gt; ubuntu_default_1453944793418_7699: Clearing any previously set forwarded ports…==&gt; ubuntu_default_1453944793418_7699: Exporting VM…==&gt; ubuntu_default_1453944793418_7699: Compressing package to: /Users/pollyduan/vm/tmp/ubuntu_myproject_test.box 导出后，可以通过IM、ftp或其他方式分发给小伙伴，那么大家使用的环境就是一致的了。 2 操作虚拟机 2.1 启动vm 2.1.1 对于单虚拟机$ vagrant up 2.1.2 如果同一个Vagrantfile定义了一个以上的虚拟机，则：$ vagrant up [vm-name]其他命令类似。如果省略vm-name，则依次启动所有vm。 2.2 重启$ vagrant reload [vm-name] 2.3 关机$ vagrant halt [vm-name] 2.4 销毁虚拟机$ vagrant destroy [vm-name] 2.5 ssh登录虚拟机$ vagrant ssh [vm-name] 2.6 休眠与唤醒这一对冤家也无需多说，对于开发环境来说，个人觉得用处不是很大。$ vagrant suspend==&gt; default: Saving VM state and suspending execution…$ vagrant statusCurrent machine states: default saved (virtualbox) To resume this VM, simply run vagrant up.$ vagrant resume==&gt; default: Resuming suspended VM…==&gt; default: Booting VM……… 2.7 快照vagrant snapshot命令是vm的月光宝盒，如果vm中有任务没有跑完，需要关闭virtual box，就可以给vm做一个快照，保存vm当前所有的状态，在virtualbox重新启动后，再回复快照。2.7.1 查看当前保存的快照$ vagrant snapshot list==&gt; default: No snapshots have been taken yet! 2.7.2 创建一个命名快照$ vagrant snapshot save shot1==&gt; default: Snapshotting the machine as ‘shot1’…$ vagrant snapshot listshot1 2.7.3 恢复快照$ vagrant snapshot restore shot1==&gt; default: Forcing shutdown of VM…==&gt; default: Restoring the snapshot ‘shot1’……… 恢复后，快照会一直存在，直到你手动删除它。 2.7.4 删除快照$ vagrant snapshot delete shot1==&gt; default: Deleting the snapshot ‘shot1’…Progress: 90%Progress: 100%==&gt; default: Snapshot deleted! 这个操作会删除持久化的数据文件，稍微有点慢，耐心等待。这个内在的原理没有深入研究，有点不太理解，删除一个文件理论上应该比保存一个文件更快才对。 2.7.5 盗梦空间push和pop，每调用一次push命令会自动创建一个命名快照，名为：push+一串随机数，如：push_1455524411_6632；每调用一次pop，会逐级恢复到最新的快照，并删除快照。看例子：$ vagrant snapshot list==&gt; default: No snapshots have been taken yet!$ vagrant snapshot push==&gt; default: Snapshotting the machine as ‘push_1455525041_2882’…$ vagrant snapshot listpush_1455525041_2882$ vagrant snapshot push==&gt; default: Snapshotting the machine as ‘push_1455525049_7456’…$ vagrant snapshot push==&gt; default: Snapshotting the machine as ‘push_1455525058_6891’…$ vagrant snapshot listpush_1455525041_2882push_1455525049_7456push_1455525058_6891$ vagrant snapshot pop==&gt; default: Forcing shutdown of VM…==&gt; default: Restoring the snapshot ‘push_1455525058_6891’…==&gt; default: Deleting the snapshot ‘push_1455525058_6891’…==&gt; default: Snapshot deleted!$ vagrant snapshot listpush_1455525041_2882push_1455525049_7456 Tips: 文本的日志看起来还不够形象，在push三个snapshot后在virtual box中是树形显示的；每次pop，树枝会逐级退回，看起来更像穿越的感觉。Tips: 在pop清空之前，随时可以通过restore恢复其中一个快照，同样快照不会删除；不影响pop的测试。 2.8 远程连接分享远程连接通过share connect两个命令可以实现通过本机vagrant连接另外一台host上的虚机。2.8.1 允许ssh连接$ vagrant share –ssh==&gt; default: Detecting network information for machine… default: Local machine address: 127.0.0.1 default: default: Note: With the local address (127.0.0.1), Vagrant Share can only default: share any ports you have forwarded. Assign an IP or address to your default: machine to expose all TCP ports. Consult the documentation default: for your provider (‘virtualbox’) for more information. default: default: An HTTP port couldn’t be detected! Since SSH is enabled, this is default: not an error. If you want to share both SSH and HTTP, please set default: an HTTP port with --http. default: default: Local HTTP port: disabled default: Local HTTPS port: disabled default: SSH Port: 2200 default: Port: 2200==&gt; default: Generating new SSH key… default: Please enter a password to encrypt the key: [输入授权密码] default: Repeat the password to confirm:[再输一次] default: Inserting generated SSH key into machine…==&gt; default: Checking authentication and authorization…==&gt; default: Creating Vagrant Share session… default: Share will be at: vile-ibex-8238==&gt; default: Your Vagrant Share is running! Name: vile-ibex-8238==&gt; default:==&gt; default: You’re sharing your Vagrant machine in “restricted” mode. This==&gt; default: means that only the ports listed above will be accessible by==&gt; default: other users (either via the web URL or using vagrant connect).==&gt; default:==&gt; default: You’re sharing with SSH access. This means that another user==&gt; default: simply has to run vagrant connect --ssh vile-ibex-8238==&gt; default: to SSH to your Vagrant machine.==&gt; default:==&gt; default: Because you encrypted your SSH private key with a password,==&gt; default: the other user will be prompted for this password when they==&gt; default: run vagrant connect --ssh. Please share this password with them==&gt; default: in some secure way. Tips: 你可以通过–name指定一个名称，否则会随机生成一个共享名，如本例中的vile-ibex-8238 2.8.2 连接远端ssh虚机$ vagrant connect –ssh vile-ibex-8238 –static-ip 10.2.136.211Loading share ‘vile-ibex-8238’…The SSH key to connect to this share is encrypted. You will requirethe password entered when creating to share to decrypt it. Verify youaccess to this password before continuing. Press enter to continue, or Ctrl-C to exit now.[回车]Password for the private key:[输入授权密码]Executing SSH…vagrant@vagrant-ubuntu-trusty-64:~$ 2.8.3 共享httpvagrant share可以把host主机的http开放到远端，供任何人访问，这好像跟vm没什么关系，但的确它发生了。$ ~/apache-tomcat-8.0.28/bin/startup.sh$ vagrant share –http 80==&gt; default: Detecting network information for machine… default: Local machine address: 127.0.0.1 default: default: Note: With the local address (127.0.0.1), Vagrant Share can only default: share any ports you have forwarded. Assign an IP or address to your default: machine to expose all TCP ports. Consult the documentation default: for your provider (‘virtualbox’) for more information. default: default: Local HTTP port: 80 default: Local HTTPS port: disabled default: Port: 2200==&gt; default: Checking authentication and authorization…==&gt; default: Creating Vagrant Share session… default: Share will be at: enchanting-buffalo-1493==&gt; default: Your Vagrant Share is running! Name: enchanting-buffalo-1493==&gt; default: URL: http://enchanting-buffalo-1493.vagrantshare.com==&gt; default:==&gt; default: You’re sharing your Vagrant machine in “restricted” mode. This==&gt; default: means that only the ports listed above will be accessible by==&gt; default: other users (either via the web URL or using vagrant connect). 我的host电脑在内网，在外网的任意一台电脑上，访问http://enchanting-buffalo-1493.vagrantshare.com，奇迹发生了。 话说这个有什么用呢？别忘记，vagrant有一个端口映射的功能，在后面的Vagrantfile配置里会提到，这样做的结果，就是可以在互联网任意一个角落可以访问到你的虚机的http服务。 2.9 windows相关的操作powershelgl和rdp是windows vm相关的操作，未做测试，忽略。 2.10 虚机环境部署provision用于通过Vagrantfile配置文件，对vm进行部署，如安装软件，发布应用等，在这里不多说，专门一章来记录。 2.11 指定vmid操作虚拟机在3.3.2中，我们可以看到当前工作机中的所有虚机，其中第一列数据为vmid，我们可以无需进入vagrant工作目录，操作这些虚机。如：$ vagrant up 63093ce 该方式适用于前面提到的up、reload、halt、destroy等命令。 3 监控虚拟机3.1 查看sshd配置信息$ vagrant ssh-configHost default HostName 127.0.0.1 User vagrant Port 2222 UserKnownHostsFile /dev/null StrictHostKeyChecking no PasswordAuthentication no IdentityFile “/Users/pollyduan/vm/ubuntu/.vagrant/machines/default/virtualbox/private_key” IdentitiesOnly yes LogLevel FATAL 3.2 查看虚拟机开放的端口$ vagrant portThe forwarded ports for the machine are listed below. Please note thatthese values may differ from values configured in the Vagrantfile if theprovider supports automatic port collision detection and resolution. 22 (guest) =&gt; 2222 (host)3.3 查看虚拟机状态3.3.1 查看当前vm状态$ cd ~/vm/ubuntu$ vagrant statusCurrent machine states: default poweroff (virtualbox) The VM is powered off. To restart the VM, simply run vagrant up 状态可能是：not create | 执行vagrant init命令后，从未启动过poweroff | 关机running | 运行中saved | 休眠 3.3.2 查看全部虚机状态此命令无需进入vagrant工作目录。$ vagrant global-status id name provider state directorybe5dee2 mfsmaster virtualbox poweroff /Users/pollyduan/vm/mfsa523de6 mfschunk1 virtualbox poweroff /Users/pollyduan/vm/mfs8377e0d mfschunk2 virtualbox poweroff /Users/pollyduan/vm/mfsb772b1f metalogger virtualbox poweroff /Users/pollyduan/vm/mfs8a5f10e mfsclient virtualbox poweroff /Users/pollyduan/vm/mfs63093ce default virtualbox poweroff /Users/pollyduan/vm/ubuntu 你可能会发现，为什么有的是default，有的是有名字的。这就是因为mfsxxxx是在vagrantfile中指定了vb.name，他对应的virtualbox工作目录也是这个值，而ubuntu这个虚机没有指定，所以是default，而且其virtualbox工作目录也是比较长的——ubuntu_default_1453944793418_7699。 global-status统计信息不是实时的，所有不能保证数据是绝对准确的。如果在vagrant up启动后，我们在virtualbox管理终端关闭vm，global-status是捕获不到的，它还是会显示running状态。截至1.8.1还是这样的，应该算是一个bug。处女座可能无法接受这个现实，那么你可以进入vagrant工作目录，手动再指定一次vagrant halt，状态就同步了。 4 其他命令4.1 help略。 4.2 login登录到中央仓库 4.3 plugin插件管理，略。 4.4 push发布镜像到中央仓库 4.5 version略。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用PHP将HTML页面生成PDF文档]]></title>
    <url>%2F%2Fmo-ren-fen-lei%2Fgenerate-pdf-documents-from-html-pages-using-php.html</url>
    <content type="text"><![CDATA[利用PHP将HTML页面生成PDF文档标签（空格分隔）： php特殊处理 使用TCPDF第三方类库进行生成githup下载地址：https://github.com/tecnickcom/tcpdf官方下载地址：http://sourceforge.net/projects/tcpdf/ 核心代码： 12345678910111213141516171819202122232425public static function writePdf($content) &#123; $pdf = new TCPDF(PDF_PAGE_ORIENTATION, PDF_UNIT, PDF_PAGE_FORMAT, true, 'UTF-8', false); $pdf-&gt;SetCreator(PDF_CREATOR); $pdf-&gt;SetHeaderData("logo.jpg", 70, 'wanglibao Agreement' . '', ''); $pdf-&gt;SetDefaultMonospacedFont(PDF_FONT_MONOSPACED); $pdf-&gt;SetMargins(PDF_MARGIN_LEFT, PDF_MARGIN_TOP, PDF_MARGIN_RIGHT); $pdf-&gt;SetHeaderMargin(PDF_MARGIN_HEADER); $pdf-&gt;SetFooterMargin(PDF_MARGIN_FOOTER); $pdf-&gt;SetAutoPageBreak(TRUE, PDF_MARGIN_BOTTOM); $pdf-&gt;setImageScale(PDF_IMAGE_SCALE_RATIO); $pdf-&gt;AddPage(); $pdf-&gt;setPageMark(); $pdf-&gt;SetFont('stsongstdlight', '', 13); $title = &lt;&lt;&lt;EOD&lt;h2&gt;标题&lt;/h2&gt;EOD; $pdf-&gt;writeHTML($content, true, false, false, false, '');// $pdf-&gt;writeHTML($content, true, 0, true, true);// $pdf-&gt;writeHTMLCell(0, 0, '', '', $content, 0, 1, 0, true, 'C', true); $pdf-&gt;lastPage(); $pdf-&gt;Output(date('Y-m-d') . '.pdf', 'I');&#125; 汉子出现乱码解决办法： 设置$pdf-&gt;setHeaderFont(array(PDF_FONT_NAME_MAIN,&#39;&#39;,PDF_FONT_SIZE_MAIN);其中PDF_FONT_NAME_MAIN就是设置头部的字体编码。将PDF_FONT_NAME_MAIN设置为 msungstdlight。页面中的字体：在 $pdf-&gt;writeHtml() ;或者$pdf-&gt;Cell();等之前设置 $pdf-&gt;SetFont(msungstdlight,&#39;&#39;, 字体大小)。 汉字不出现乱码的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php//引入tcpdf文件 require_once('./TCPDF-master/tcpdf.php'); //实例化 $pdf = new TCPDF('P', 'mm', 'A4', true, 'UTF-8', false); // 设置文档信息 $pdf-&gt;SetCreator('哈喽'); $pdf-&gt;SetAuthor('作者'); $pdf-&gt;SetTitle('哈哈哈哈哈哈'); $pdf-&gt;SetSubject('TCPDF Tutorial'); $pdf-&gt;SetKeywords('TCPDF, PDF, PHP'); // 设置页眉和页脚信息 $pdf-&gt;SetHeaderData('logo.png', 10, 'kkkkkk', '就是做个PDF', array(0,64,255), array(0,64,128)); $pdf-&gt;setFooterData(array(0,64,0), array(0,64,128)); // 设置页眉和页脚字体 $pdf-&gt;setHeaderFont(Array('stsongstdlight', '', '10')); $pdf-&gt;setFooterFont(Array('helvetica', '', '8')); // 设置默认等宽字体 $pdf-&gt;SetDefaultMonospacedFont('courier'); // 设置间距 $pdf-&gt;SetMargins(15, 27, 15); $pdf-&gt;SetHeaderMargin(5); $pdf-&gt;SetFooterMargin(10); // 设置分页 $pdf-&gt;SetAutoPageBreak(TRUE, 25); // set image scale factor $pdf-&gt;setImageScale(1.25); // set default font subsetting mode $pdf-&gt;setFontSubsetting(true); //设置字体 $pdf-&gt;SetFont('stsongstdlight', '', 14); $pdf-&gt;AddPage(); $str1 = " &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;哈哈&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;"; $pdf-&gt;WriteHTML($str1,'', 0, 'L', true, 0, false, false, 0); //输出PDF $pdf-&gt;Output('t.pdf', 'I');]]></content>
      <categories>
        <category>默认分类</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js实现mqtt 发布/发送 消息到主题]]></title>
    <url>%2F%2Ftechnology%2Fweb-nodemqtt.html</url>
    <content type="text"><![CDATA[node.js实现mqtt 发布/发送 消息到主题标签（空格分隔）： mqtt mqtt是啥?我的博客有写这个东西:传送门 安装首先你要安装node.js和npm 教程传送门 随后找个文件夹执行 命令行 安装mqtt模块; 1npm install mqtt 如果需要服务端 执行 1npm install mosca 使用 mqtt的文档 以下代码中有些参数可以从mqtt官方文档中得到解释 node.js中mqtt模块文档 mqtt协议入门文章 服务端123456789101112131415161718192021222324252627282930313233var mosca = require(&apos;mosca&apos;);//构建自带服务器var MqttServer = new mosca.Server(&#123; port: 1883&#125;);//对服务器端口进行配置， 在此端口进行监听MqttServer.on(&apos;clientConnected&apos;, function(client) &#123; //监听连接 console.log(&apos;client connected&apos;, client.id);&#125;);/** * 监听MQTT主题消息 **/MqttServer.on(&apos;published&apos;, function(packet, client) &#123; //当客户端有连接发布主题消息 var topic = packet.topic; console.log(packet); switch (topic) &#123; case &apos;test&apos;: console.log(&apos;message-publish&apos;, packet.payload.toString()); //MQTT转发主题消息 MqttServer.publish(&#123; topic: &apos;other&apos;, payload: &apos;sssss&apos; &#125;); break; case &apos;other&apos;: console.log(&apos;message-123&apos;, packet.payload.toString()); break; &#125;&#125;);MqttServer.on(&apos;ready&apos;, function() &#123; //当服务开启时 console.log(&apos;mqtt is running...&apos;);&#125;); PS: 不推荐node.js 作服务端 发布消息到主题123456789var mqtt = require(&apos;mqtt&apos;);var client = mqtt.connect(&apos;mqtt://127.0.0.1&apos;); //连接到服务端//client.subscribe(&apos;presence&apos;);var num = 0;var qtt = &#123;&#125;; //定义消息（可以为字符串、对象等）qtt = &apos;setr=xxxxxxx1xx&apos;;setInterval(function() &#123; //一秒钟发送一次 消息到主题 SN69143809293670state 消息为 setr=xxxxxxx1xx client.publish(&apos;SN69143809293670state&apos;, qtt, &#123; qos: 0, retain: true &#125;); &#125;, 1000); 订阅主题12345678var mqtt = require(&apos;mqtt&apos;); var client2 = mqtt.connect(&quot;mqtt://127.0.0.1:1883&quot;); //指定服务端地址和端口 client2.subscribe(&apos;test&apos;,&#123;qos:1&#125;);//订阅主题为test的消息 client2.on(&apos;message&apos;,function(top,message) &#123; console.log(message.toString()); &#125;); 制作接口(简化)我所接触的这个物理设备是发送给他一个 控制 或者 查询 请求到他订阅的主题中(ctr),并且它接收到控制信息,去执行.执行成功时 则会将 状态 发送到另一个 我订阅的主题中 .使用php实现比较麻烦,并且返回信息时有时无,使用node.js更方便,返回信息也更快; 物理环境 :centos7.2 64位,装有mqtt服务代理端mosquitto或其他mqtt协议代理. 安装可以自行搜索一下 和 node.js; 需要安装http 和 express 以及 mqtt 模块 npm install 模块名 node.js http模块文档 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182var mqtt = require(&apos;mqtt&apos;);var express = require(&quot;express&quot;);var app = express();var hostName = &apos;127.0.0.1&apos;; //http服务的提供服务ipvar port = 8080;var num = 1;person = new Object();person.firstname = &quot;Bill&quot;;app.all(&apos;*&apos;, function(req, res, next) &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;); res.header(&quot;X-Powered-By&quot;, &apos; 3.2.1&apos;) res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); next();&#125;);//json header头app.get(&quot;/zhinengjiaju/get&quot;, function(req, res) &#123; //如果有get请求/zhinengjiaju/get则执行回调中的代码(方便!) // console.log(&quot;请求url：&quot;, req.path) // console.log(&quot;请求参数：&quot;, req.query) req.setTimeout(200); //设置请求建立200ms 就中断接受请求,但还是在接收到返回信息后返回给它 var client = mqtt.connect(&apos;mqtt://127.0.0.1:1883&apos;, &#123; username: &apos;username&apos;, password: &apos;password&apos;, clientId: &apos;ap&apos; + num &#125;); //建立连接 client.on(&apos;connect&apos;, function() &#123; var sn = req.query.sn; var k = parseInt(req.query.k) - 1; // 127.0.0.1:8080/zhinengjiaju/get?sn=SN69143809293670&amp;k=1&amp;v=3&amp;cmd=setr client.subscribe(sn + &apos;state&apos;, &#123; qos: 1 &#125;); //开始订阅 if (req.query.cmd != &apos;setr&apos;) &#123; m = req.query.cmd; if (req.query.cmd == &apos;qk&apos;) &#123; m = &apos;setr=1111111111&apos;; &#125; if (req.query.cmd == &apos;qg&apos;) &#123; m = &apos;setr=0000000000&apos;; &#125; &#125; else &#123; var m = [&apos;x&apos;, &apos;x&apos;, &apos;x&apos;, &apos;x&apos;, &apos;x&apos;, &apos;x&apos;, &apos;x&apos;, &apos;x&apos;, &apos;x&apos;, &apos;x&apos;]; m[k] = req.query.v;; m = req.query.cmd + &apos;=&apos; + m.join(&apos;&apos;); &#125; //一系列简单接口处理 client.publish(sn + &apos;ctr&apos;, m, &#123; qos: 1, retain: true &#125;); // &apos;Hello mqtt &apos; + (num++) //发送 client.end(); //发送完后立即结束此次和服务端建立的请求 &#125;); client.on(&apos;message&apos;, function(topic, message) &#123; //订阅信息一直在运行,如果有设备返回信息到主题,就执行此回调 aaak(message.toString()); //将值通过aaak函数传递给res.end返回给页面数据; client.end(); &#125;); function aaak(aaaa) &#123; var objaaaa = JSON.parse(aaaa); // console.log(objaaaa); num++; client.end(); res.end(aaaa); &#125;&#125;)app.listen(port, hostName, function() &#123; console.log(`服务器运行在http://$&#123;hostName&#125;:$&#123;port&#125;`);&#125;); 谢谢支持,感觉不错打个赏;]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
      <tags>
        <tag>mqtt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker镜像下载\删除\查看命令_参数详解]]></title>
    <url>%2F%2Fnote%2Fdocker-image-download-delete-view-command-parameters-detailed.html</url>
    <content type="text"><![CDATA[Docker镜像下载\删除\查看命令_参数详解标签（空格分隔）： docker 镜像 下载\删除\查看: 镜像 下载: 1) . 下载最新系统 1docker pull centos 这里的centos是系统,如果后面不指定系统详细版本号会下载镜像源最新系统 * 2).*下载指定版本系统** 1docker pull centos:6.6 下载不同版本在centos后面加上冒号然后是版本号 后面使用的版本号依据搜索出来的镜像提供的一些版本编号来填写 3).Docker常用搜索镜像下载地址:Docker官网的镜像搜索阿里云提供的国内镜像下载 镜像 删除\查看: 1.停止所有的经过镜像实例化运行的容器，这样才能够删除其中的images： 查看容器: 12345678910111213141516docker ps 主要有些参数要说一下 1. 不加参数，表示查看当前正在运行的容器 2. -a，查看所有容器包括停止状态的容器 3. -l，查看最新创建的容器 4. -n=x，查看最后创建的x个容器 列一下docker ps的结果 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 这些分别代表什么 CONTAINER ID：容器ID，唯一标识容器 IMAGE：创建容器时所用的镜像 COMMAND：在容器最后运行的命令 CREATED：容器创建的时间 STATUS：容器的状态（你会看到UPXXX，表示运行状态） PORTS：对外开放的端口号 NAMES：容器名（也具有唯一性，docker是不允许创建容器名相同的容器的） stop [OPTIONS] CONTAINER [CONTAINER...]```1 options 名字 简写 默认 描述–time -t 10 秒杀之前等待停止 1232.查看当前有些什么images```docker images 3.删除images，通过image的id来指定删除谁 rmi [OPTIONS] IMAGE [IMAGE...]```123456``` options 名字 简写 描述--force -f 强制删除图像--no-prune 不要删除未标记的父母 例子: $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE test1 latest fd484f19954f 23 seconds ago 7 B (virtual 4.964 MB) test latest fd484f19954f 23 seconds ago 7 B (virtual 4.964 MB) test2 latest fd484f19954f 23 seconds ago 7 B (virtual 4.964 MB) $ docker rmi fd484f19954f Error: Conflict, cannot delete image fd484f19954f because it is tagged in multiple repositories, use -f to force 2013/12/11 05:47:16 Error: failed to remove one or more images $ docker rmi test1 Untagged: test1:latest $ docker rmi test2 Untagged: test2:latest $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE test latest fd484f19954f 23 seconds ago 7 B (virtual 4.964 MB) $ docker rmi test Untagged: test:latest Deleted: fd484f19954f4920da7ff372b5067f5b7ddb2fd3830cecd17b96ea9e286ba5b8 #### 问题回顾 删除时出现 12$ docker rmi 196e0ce0c9fbError response from daemon: conflict: unable to delete 196e0ce0c9fb (must be forced) - image is referenced in multiple repositories 可以尝试 docker rmi daocloud.io/centos #REPOSITORY 栏中的文字 再次删除时出现 Untagged: daocloud.io/centos:latest 尝试删除 docker rmi #IMAGE ID 栏中的文字 问题示例： 123456789101112131415161718192021222324252627282930313233Administrator@DESKTOP-679OPI8 MINGW64 ~$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESAdministrator@DESKTOP-679OPI8 MINGW64 ~$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdaocloud.io/centos 7 196e0ce0c9fb 5 months ago 197MBdaocloud.io/centos latest 196e0ce0c9fb 5 months ago 197MBAdministrator@DESKTOP-679OPI8 MINGW64 ~$ docker rmi 196e0ce0c9fbError response from daemon: conflict: unable to delete 196e0ce0c9fb (must be forced) - image is referenced in multiple repositoriesAdministrator@DESKTOP-679OPI8 MINGW64 ~$ docker rmi daocloud.io/centosUntagged: daocloud.io/centos:latestAdministrator@DESKTOP-679OPI8 MINGW64 ~$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdaocloud.io/centos 7 196e0ce0c9fb 5 months ago 197MBAdministrator@DESKTOP-679OPI8 MINGW64 ~$ docker rmi daocloud.io/centosError: No such image: daocloud.io/centosAdministrator@DESKTOP-679OPI8 MINGW64 ~$ docker rmi 196e0ce0c9fbUntagged: daocloud.io/centos:7Untagged: daocloud.io/centos@sha256:822de5245dc5b659df56dd32795b08ae42db4cc901f3462fc509e91e97132dc0Deleted: sha256:196e0ce0c9fbb31da595b893dd39bc9fd4aa78a474bbdc21459a3ebe855b7768Deleted: sha256:cf516324493c00941ac20020801553e87ed24c564fb3f269409ad138945948d4]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker配置开发环境常用命令_参数详解(1]]></title>
    <url>%2F%2Fnote%2Fdocker-configuration-development-environment-commonly-used-commands-parameters-detailed-1.html</url>
    <content type="text"><![CDATA[Docker配置开发环境常用命令_参数详解标签（空格分隔）： docker 在下载image后我们需要一个可以运行项目的环境 使用下载的image运行容器命令：docker run 123456789当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：检查本地是否存在指定的镜像，不存在就从公有仓库下载利用镜像创建并启动一个容器分配一个文件系统，并在只读的镜像层外面挂载一层可读写层从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去从地址池配置一个 ip 地址给容器执行用户指定的应用程序执行完毕后容器被终止 用法 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] Options 名字，速记默认描述--add-host添加一个自定义的主机IP映射（主持人：IP）--attach , -aattach到stdin stdout或stderr，--blkio-weight块IO（相对量），10和1000之间，或0禁用（默认为0）--blkio-weight-device块IO量（相对装置重量）--cap-add添加Linux的功能--cap-dropLinux的能力下降--cgroup-parent可选的父容器的C--cidfile写容器的ID文件--cpu-countCPU数量（Windows）--cpu-percentCPU的百分比（Windows）--cpu-period限制CPU CFS（完全公平调度器）期--cpu-quota限制CPU CFS（完全公平调度器）定额--cpu-rt-periodAPI 1.25限制CPU的实时周期在微秒--cpu-rt-runtimeAPI 1.25限制CPU的实时运行在微秒--cpu-shares , -cCPU份额（相对量）--cpusAPI 1.25CPU数量--cpuset-cpus这允许CPU执行（0，0）--cpuset-memsMEMS中允许执行（0，0）--detach , -d运行容器的背景和打印容器ID--detach-keys分离容器覆盖关键序列--device添加一个主机装置的容器--device-cgroup-rule添加一条规则，允许设备列表的C--device-read-bps限制读取速度（每秒字节数）从设备--device-read-iops限制读取率（IO每秒）从设备--device-write-bps限制写速率（每秒字节数）的一种装置--device-write-iops限制写速率（IO每秒）的一种装置--disable-content-trusttrue跳过图像验证--dns设置自定义的DNS服务器--dns-opt设置DNS选项--dns-option设置DNS选项--dns-search设置自定义DNS搜索域--entrypoint覆盖图像的默认入口点--env , -e设置环境变量--env-file在一个环境变量文件读取--expose揭露一个端口或端口范围--group-add添加额外的团体加入--health-cmd要运行的命令来检查卫生--health-interval之间运行的检查时间（MS |的| M | H）（默认0s）--health-retries连续的失败需要报告不良--health-start-periodAPI 1.29对于容器初始化之前开始倒计时起始期健康重试（MS |的| M | H）（默认0s）--health-timeout允许一个检查运行的最大时间（MS |的| M | H）（默认0s）--help打印使用--hostname , -h容器的主机名称--initAPI 1.25运行容器内转发信号和收获过程中的一个初始化--interactive , -i保持输入打开即使不连接--io-maxbandwidth的驱动系统的最大IO带宽限制（仅适用于Windows）--io-maxiops对系统驱动Maximum IOps极限（Windows）--ipIPv4地址（例如，172.30.100.104）--ip6IPv6的地址（例如，2001：db8：：33）--ipcIPC模式使用--isolation容器隔离技术--kernel-memory内核内存限制--label , -l设置元数据容器--label-file读一行分隔的文件标签--link添加链接到另一个容器--link-local-ip集装箱IPv4和IPv6链路本地地址--log-driver测井的集装箱司机--log-opt日志驱动器选项--mac-address集装箱的MAC地址（例如92：D0：c6:0a：29:33）--memory , -m内存限制--memory-reservation记忆软限制--memory-swap互换限额等于内存和交换：&amp;#39; 1 &amp;#39;使无限的互换--memory-swappiness-1调容器内存swappiness（0到100）--mount将文件系统挂载到容器--name在容器分配一个名字--net连接到网络的一个容器--net-alias添加网络域别名容器--network连接到网络的一个容器--network-alias添加网络域别名容器--no-healthcheck禁用任何容器指定的检查--oom-kill-disable禁用OOM Killer--oom-score-adj调主机的OOM的偏好（1000到1000）--pidPID命名空间的使用--pids-limit调整PID（集1容器极限无限）--platform实验（守护）API 1.32如果服务器是多平台可设置平台--privileged给这个容器扩展权限--publish , -pPublish a container’s port(s) to the host--publish-all , -P发布所有暴露的端口随机端口--read-only装入容器的根文件系统为只读--restartno重启政策适用在集装箱出口--rm自动删除容器时退出--runtime运行时使用此容器--security-opt安全选项--shm-size大小/ dev / shm--sig-proxytrue代理接收到的信号的过程--stop-signalSIGTERM信号停止一个容器--stop-timeoutAPI 1.25超时（秒）停止一个容器--storage-opt对于集装箱存储驱动程序选项--sysctlsysctl选项--tmpfs安装tmpfs目录--tty , -t分配给伪tty--ulimitulimit选项--user , -uUsername or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])--userns用户要使用的名称空间--utsUTS命名空间的使用--volume , -v绑定安装卷--volume-driver容器的体积驱动可选--volumes-from山卷从指定的容器（S）--workdir , -w容器内的工作目录 1234------------##### 非主流用法：###### 使用image创建container并执行相应命令，然后停止 $ docker run centos echo ‘123’Unable to find image ‘centos:latest’ locallylatest: Pulling from library/centosaf4b0a2388c6: Pull completeDigest: sha256:2671f7a3eea36ce43609e9fe7435ade83094291055f1c96d9d1d1d7c0b986a5dStatus: Downloaded newer image for centos:latestps:以上是下载最新的centos过程123 1234567891011 这是最简单的方式，跟在本地直接执行echo &apos;hello world&apos; 几乎感觉不出任何区别，而实际上它会从本地 **centos:latest** 镜像启动到一个容器并执行打印命令后退出（docker ps -l可查看）。 需要注意的是，默认有一个 **--rm=true** 参数，即完成操作后停止容器并从文件系统移除。因为Docker的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。容器启动后会自动随机生成一个CONTAINER ID，这个ID在后面commit命令后可以变为IMAGE ID##### 主流用法：###### 使用image创建container并进入交互模式, login shell是/bin/bash`docker run -i --name cee -t centos:7.2.1511 /bin/bash`使用示例： 12docker run -i --name cee -t centos:7.2.1511 /bin/bash[root@90df89d56b3e /]# 使用到的option： |参数|含义||—|—|—||-i |保持输入打开即使不连接（类似于后台运行）||–name |标记可以为容器自定义命名||-t |docker可以虚拟出一个TTY窗口|]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker配置开发环境常用命令_参数详解(3]]></title>
    <url>%2F%2Fnote%2Fdocker-configuration-development-environment-commonly-used-commands-parameters-detailed-3.html</url>
    <content type="text"><![CDATA[文章不兼容, 已放到时光机]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer组件开发]]></title>
    <url>%2F%2Ftechnology-php%2Fcomposer-component-development.html</url>
    <content type="text"><![CDATA[composer组件开发标签（空格分隔）： composer组件开发 http://www.chenjie.info/1880 入门https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE git tag 标签使用https://packagist.org/about#how-to-update-packages 官方教程(包括自动更新)]]></content>
      <categories>
        <category>PHP技术栈</category>
      </categories>
      <tags>
        <tag>composer</tag>
      </tags>
  </entry>
</search>
